---------------------------------------------------------------------------------------------------------------------------------------------------|
| APUNTES GENERALES DE JAVA - CURSO UDEMY UNIVERSIDAD JAVA.                                                                                        |
---------------------------------------------------------------------------------------------------------------------------------------------------|
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS                                                                                                                         |
---------------------------------------------------------------------------------------------------------------------------------------------------|
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 02 - INSTALACIÓN JAVA Y APACHE NETBEANS 
|  VIDEOS: 2, 3, 4, 5
---------------------------------------------------------------------------------------------------------------------------------------------------|

- Grupos de Java.

1) Java JSE (Java Standar Edition): Aplicaciones de tipo Escritorio Windows.
	
	- Aplicaciones independientes.
	- Aplicaciones distribuidas.
	- Applets para navegadores Web.

2) Java JEE: (Java Enterprise Edition): Aplicaciones tipo empresarial.

	- Aplicaciones empresariales 
	- Comercio electrónico.
	- Aplicaciones Web.

3) Java JME (Java Movile Edition): Aplicaciones móviles.

	- Aplicaciones móviles.
	- Aplicaciones PDA.
	- Aplicaciones televisión.
	- Aplicaciones para microchips.

- Programas a instalar.

1) JDK: Java SE Developer Kit: Software que provee herramientas de desarrollo para la creación de programas en Java.

	Los programas más importantes que se incluyen en el JDK son:

	- appletviewer.exe: Visor de applets para generar sus vistas previas, ya que un applet carece de método main y no se puede ejecutar con el 
                      programa java.
	- javac.exe: Compilador de Java.
	- java.exe: Intérprete de Java.
	- javadoc.exe: Genera la documentación de las clases Java de un programa.

2) JRE: Java Runtime Enviroment: Conjunto de utilidades que permite la ejecución de programas Java.
3) IDE Apache Netbeans: Software utilizado para el desarrollo de programación en Java.

- Creación de un nuevo proyecto en Java.
	
	- File -> "New Proyect.." (Ctrl + Shift + N). 
	- Elegimos la categoria "Java with Ant", como tipo de proyecto elegimos la opción "Java Application" y pulsamos el botón de "Next".
	- Se indica nombre del proyecto, ruta donde se va a guardar dichos archivos y se marca la opción que te añada el "Create main class" que es la 
    clase principal del proyecto de forma automática.
	- Se pulsa en "Finish" y ya esta el proyecto nuevo creado.

- Compilación y ejecución de un archivo Java.

	- En Netbeans, se debe de hacer click derecho sobre el nombre del archivo a compilar con la extensión ".java" y elegimos la opción "Run File" 
    (Shift + F6).

- Utilizar el Debug con Netbeans.
	
	- Se debe de pulsar en la parte izquierda, donde aparecen los nº de filas del editor, para poner un punto de ruptura y hacer que el proceso se 
    pare en dicho punto. Sólo se puede poner un punto de ruptura en las lineas donde se ejecuta algún tipo de código, no vale en las 
    declaraciones de paquetes, clases o métodos.
	- Se pulsa botón derecho del ratón y se selecciona la opción "Debug File" (Ctrl + Shift + F5).
	- En la barra de herramientas, se nos activan los botones de Debug, como son:

		- Finish Debuger (Shift + F5): Detiene el modo Debug.
		- Pausar.
		- Continue (F5): Hace que se quite el modo debug y compile todo el proceso como si no tuviera un punto de ruptura de Debug.

		- Step Over (F8): Ejecuta la linea que tenga marcada el debug pero sin meterse dentro del metodo o procedimiento que se esté utilizando.
		- Step Over Expression (Shift + F8): 
		- Step Into (F7): Ejecuta la linea que tenga marcada el debug pero metiendose dentro del metodo que se esté utilizando.
		- Step Out (Ctrl + F7): Se sale del metodo en el cual hemos entrado pulsando la opción "Step Into".

- Tablas caracteres UNICODE para variables tipo CHAR.

	http://www.icursos.net/referencias/TablaUnicode.html

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 03 y 04 - TIPOS DE DATOS Y VARIABLES EN JAVA 
|  VIDEOS: 7, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20.
---------------------------------------------------------------------------------------------------------------------------------------------------|

Tipos de datos en Java.

  1) Tipos primitivos (Videos 7, 8, 9, 10, 15, 16, 17, 18, 19, 20):

    - Tipo Entero.

      + byte 	 (8 bits)  Default 0 -> Clase Byte.
      + short  (16 bits) Default 0 -> Clase Short.
      + int 	 (32 bits) Default 0 -> Clase Integer.
      + long 	 (64 bits) Default 0 -> Clase Long.

    - Tipo Flotante:

      + float  (32 bits) Default 0.0.
      + double (64 bits) Default 0.0.
	
	- Tipo Char.
	
	  + char
	  Lista de caracteres: https://en.wikipedia.org/wiki/List_of_Unicode_characters
	  
    - Tipo Booleano:

      + boolean Default False.

  2) Tipos referenciados (Tipo Object):

    - String Default "".
    - Clases.
    - Interfaces.
    - Arreglos (Arrays).

Tipos de variables en Java.

  - Para declarar una variable, hay que indicar el tipo de variable, luego su nombre y si se le quiere indicar un valor por defecto en la 
    declaración, pues se utiliza el operador "=". Una vez declarado, se termina la linea con el ";".
  - Para declarar una variable de tipo Object, se utiliza la palabra reservada "New" menos la variable tipo "String".

  - Declaración de variables.
	
		+ Byte: byte numeroByte = 10;
		+ Short: short numeroShort = 15;
    + Int: int miVariableEntera = 10;
    + Long: long numeroLong = 25;
    + Float numeroFloat = (float)10.45;		// Hay que añadir el (float) delante del número para que Java lo interprete como decimal.
    + Double: double numeroDouble = 20.48; 
    + Char: char variableChar = '#';
    + Cadena: String miVariableCadena = "Hola";
    + Booleano: boolean variableBoolean = true;
    + Tipo generica entero: var miVariableEntero = 20;
    + Tipo generica cadena: var miVariableCadena = "Alfonso";

- Concatenación de variables de cadena (Video 11).

  Se utiliza para ello el operador "+" con variables de tipo cadena. 

- Operadores especiales para cadenas (Video 12).

  - Salto de linea: \n
  - Tabulador: \t
  - Retroceso: \b
  - Salto de página: \f
  - Comillas simpres: \'
  - Comillas dobles: \"
  - Retorno de carro: \r
  - Barra invertida: \\
  
- Conversión de tipos de variables (Videos 21, 22).

  - Convertir variable de tipo String a un tipo Int: var w_edad = Integer.parseInt("39");
  - Convertir variable de tipo String a un tipo Double: var w_valorPI = Double.parseDouble("3.1416");
  - Convertir variable de tipo Int a un tipo String: var w_edadTexto = String.valueOf(10);
  - Convertir variable de tipo String a un tipo Boolean: var envio = Boolean.parseBoolean(DatosConsola.nextLine()); 
  
- Si la variable va a permanecer inalterable a lo largo del programa, la declararemos como constante, utilizando la palabra reservada final de la 
  siguiente forma:

  final double PI = 3.1415926536;

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 05 - OPERADORES EN JAVA 
|  VIDEOS: 24, 25, 26, 27.
---------------------------------------------------------------------------------------------------------------------------------------------------|

1) Operadores de cadena.

	- Concatenación de cadenas: +
	- Comentarios:

		+ Comentar una linea: //
		+ Comentar un párrafo: /* ... */
		+ Comentarios para la herramienta JavaDoc: /** ... */

2) Operadores aritméticos (Video 24).

	- Suma: +
	- Resta: -
	- Multiplicación: *
	- División: /
	- Resto de la división entera: %
  
3) Operadores de asignación (Video 25).
	
	- Operador de asignación: =	
	- Operadores de asignación combinados.
							 
			NOMBRE			 OPERADOR		EJEMPLO EN JAVA		  EXPRESION EQUIVALENTE
		-------------------------------------------------------------------------------
		Suma combinada 			+= 				a+ = b; 				a = a + b;
		Resta combinada 		-=				a- = b; 				a = a - b;
		Producto combinado	*=				a* = b; 				a = a * b;
		División combinada 	/=				a/ = b; 				a = a / b;
		Resto combinado			%=				a% = b; 				a = a % b;

4) Operador unario de cambio de signo (Video 26).
	
	- Cambio de signo: -

5) Operadores aritméticos incrementales (Video 26).
	
	- Incremento.
	
		+ Preincremento: Primero incrementa el valor de la variable en 1 y luego se utiliza: ++i
		+ Postincremento: Primero utiliza el valor de la variable y luego la incrementa en 1 su valor: i++
		
	- Decremento: 
	
		+ Predecremento: Primero decrementa el valor de la variable en 1 y luego se utiliza: --i 
		+ Postdecremento: Primero utiliza el valor de la variable y luego la decrementa en 1 su valor: i++
		
6) Operadores de igualdad (Video 27).
	
	- Igual que: ==
	- Distinto que: !=
	- Entre cadenas String: objetoCadena.equals()
	
7) Operadores relacionales (Video 28).

	- Mayor que: >
	- Mayor o igual que: >=
	- Menor que: <
	- Menor o igual que: <=
	
8) Operadores lógicos o booleanos (Video 29).

	- Producto lógico (AND): &
	- Suma lógica (OR): |
	- Negación (NOT): !
	- Suma lógica exclusiva (XOR): ^
	- Suma lógica con cortocircuito (Si el primer operador es True, el segundo se salta y el resultado es True): || 
	- Producto lógico con cortocircuito (Si el primer operando es False, el segundo se salta y el resultado es False): &&

9) Operador ternario (Video 30).

	- Como si fuera un decode en sql: ?: -> Ejemplo: var resultado2 = (a > b) ? "verdadero" : "falso";

10) Operadores a nivel de bits.

	- Suma lógica binaria (OR): |
	- Suma lógica exclusiva (XOR): ^
	- Producto lógico binario (AND): &
	- Desplaza a la izquierda los bits del 1º operando tantas veces como indica el 2º operando: <<
	- Desplaza a la derecha los bits del 1º operando tantas veces como indica el 2º operando: >>
	- Desplaza a la derecha los bits del 1º operando tantas veces como indica el 2º operando - sin signo: >>>

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 06 - SENTENCIAS DE CONTROL EN JAVA
|  VIDEOS: 34, 35, 36, 37, 38
---------------------------------------------------------------------------------------------------------------------------------------------------|

1) Operadores lógicos de las sentencias de control.

	- Operador AND: &&
	- Operador OR: ||

2) Operadores relacionales de las sentencias de control.

	- Mayor que: >
	- Menor que: <
	- Mayor o igual que: >=
	- Menor o igual que: <=
	- Distinto que: !=
	- Igual que: ==

Las sentencias de control son las siguientes:

Las condiciones siempre tienen que ir entre parentesis para que no de error de compilación.

1) Sentencia If Else (Video 34).

	If (condicion)	-- Valor permitido: boolean
	{
		-- Código If.
	}
	Else (condicion)
	{
		-- Código Else.
	}

2) Sentencia If Else If (Video 35).

	If (condicion)	-- Valor permitido: boolean
	{
		-- Código If.
	}
	Else if (condicion)
	{
		-- Código Else if.
	}
	Else
	{
		-- Código Else.
	}	

3) Sentencia Switch simple (Video 37).

	Switch (expresion)	-- Valores permitidos: byte, short, int, char, string.
	{
		case valor1:

			-- Código case1.
			break;	-- Hace que se salga del switch.

		case valor2:

			-- Código case2.
			break;
		
		case valorN;

			-- Código case3.
			break;

		default:

			-- Código default. 

	}

4) Sentencia Switch con varios casos (Video 38).

	Switch (expresion)	-- Valores permitidos: byte, short, int, char, string.
	{
		case valor1: case valor2: case valor3:

			-- Código case1, case2, case3.
			break;	-- Hace que se salga del switch.

		case valor4:

			-- Código case4.
			break;
		
		case valorN;

			-- Código case5.
			break;

		default:

			-- Código default. 

	}

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 07 - BUCLES O CICLOS EN JAVA 
|  VIDEOS: 40, 41, 42, 43
---------------------------------------------------------------------------------------------------------------------------------------------------|

Tipos de ciclos.

1) Ciclo While (Video 40).

	- Debido a que la condición del ciclo while se evalúa al inicio, el bloque de código a repetir no se ejecutará ni una sola vez, si es que esta 
    condición no se cumple.

	while (condicion)	-- Valor permitido: Boolean.
	{
			-- Código a repetir.
	}

2) Ciclo Do While (Video 41).

	- Debido a que la condición del ciclo do while se evalúa al final, el bloque de código a repetir se ejecutará por lo menos una vez, aunque esta 
    condición no sea verdadera.

	do -- Valor permitido: Boolean.
	{
			-- Código a repetir.
	}
	while (condicion);

3) Ciclo For (Video 42).

	- Inicialización: Variable tipo contador que se inicializa en esta sentencia.
	- Condición: Se revisa que la condición sea verdadera para ejecutar el bucle, sino no se ejecuta el bucle ni una sola vez.
	- Iteración: Una vez que se ha realizado el código, se incrementa o decrementa la variable contador cada vez que realice una vuelta.

	for (inicializacion; condicion; iteracion)	-- Valor permitido: Boolean.
	{
			-- Código a repetir.
	}
	
- Palabras reservadas Break y Continue (Video 43).

	- Break: Corta el proceso de iteración del bucle.
	- Continue: Continua el proceso de iteración del bucle.	
  
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 08 - CLASES Y OBJETOS EN JAVA 
|  VIDEOS: 45, 46
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Definición de clase (Video 45).

	Una clase es una plantilla que se utiliza para crear objetos del tipo que se ha definido en la clase, por lo que es igual a la creación de un 
  "Type" en Oracle y el objeto sería la variable de dicho "Type" que contiene toda la información de los atributos de la clase.
	
	Las clases tienen que tener:
	
	  - Nombre identificativo despues de la palabra reservada "class".
	  - Atributos o variables de la clase, tambien llamadas "Variables de instancia de nuestra clase".
	  - Métodos de la clase (Funciones o procedimientos característicos de dicha clase).
	  - Se debe guardar en un archivo con el mismo nombre de la clase y la extensión .java.
	
	Para crear un objeto de una clase, se utiliza el mismo nombre de la clase a utilizar.
	
	Al definir una clase, sólo estamos definiendo la plantilla con la que vamos a trabajar, pero para poder usar esta plantilla necesitamos crear 
	objetos a partir de esta plantilla.

2. Atributos y definición de métodos de una clase (Video 46).

	Por ejemplo, puede crearse una nueva clase llamada "Persona" que tenga como atributos de la clase (nombre, apellidos, género, etc) y 
	métodos para ejecutar las acciones que puede realizar esta persona (comer, dormir, leer, etc).
	
	Nombre de la clase: Persona
	
	Atributos:
		
		- Nombre, de tipo String.
		- Apellidos, de tipo String.
		- Género, de tipo String.
	
	Métodos:
	
		- ObtenerNombre() que devuelve un String
		- ObtenerApellidos() que devuelve un String
		- ObtenerGenero() que devuelve un String
		- ModificarNombre() que devuelve un String
		- ModificarApellidos() que devuelve un String
		- ModificarGenero() que devuelve un String 

2.1 - Declaración de la clase.
	
	class Persona
	{
		
		// Atributos de la clase.
	
		String nombre;
		String apellidos;
		String género;
	
		// Método de la clase que lo usarán los objetos de ésta clase.
		// Se declara de tipo "public" para que lo puedan usar dentro de la clase y "void" se indica porque no va a devolver ningún valor.
	
		public void ObtenerNombre()
		{
	
			// Código del método.
	
		}
	}

3. Objetos en Java (Video 47, 48).

	Un objeto es la instancia de una clase, por lo que a partir de nuestra plantilla (clase) es posible crear objetos en concreto con los
	cuales podremos trabajar (cambiar sus valores, llamar a sus métodos, etc).
	
	Para crear un objeto, se utiliza la palabra reservada "new" que significa que vamos a crear una nueva variable del tipo de la clase 
	asociada.
	
	La estructura es: 
		
		"Nombre_Clase" + "nombre_variable" + "=" + "new" + "Nombre_Clase()";
		Persona p1 = new Persona();
	
	Después de que esta línea se ejecute, la variable "p1" podrá acceder a un objeto de tipo "Persona" que va a tener asociado los 
	atributos (Nombre, Apellidos y Género) junto a los métodos (ObtenerNombre, ObtenerApellido, ObtenerGenero, ModificarNombre, 
	ModificarApellido, ModificarGenero) para poder utilizarlo con dicho objeto. 
	
	Cada vez que se manda llamar la palabra "new" se creará un nuevo objeto de tipo "Persona", y contendrá sus propios valores. 
	
	Hay que tener en cuenta, que cuando se crea un nuevo objeto, siempre al inicio, los atributos tiene por defecto el valor "Null", 
	hasta que no asignemos un valor a los atributos.
	
	Por ejemplo:
	
		Persona p2 = new Persona();
	
	Esta nueva variable "p2", apunta a un nuevo objeto de tipo "Persona", y por lo tanto contendrá valores distintos a la variable "p1". 
	Así, cada nuevo objeto contendrá valores distintos en los atributos de nombre, apellidos y género.
	
	Para acceder a los atributos de nuestras clases vamos a utilizar el operador "." A través de este operador se liga el nombre del 
	objeto con el nombre del atributo de la clase.
	
	La estructura es:
	
		"nombre_variable_objeto" + "." + "nombre_atributo_clase";
	
	Por ejemplo: 
		
		p1.nombre = "Alfonso";
		p1.apellidos = "Lopez Jimenez";
		p2.genero = "Hombre";
	
		p2.nombre = "Isabel";
		p2.apellidos = "Ferral Cabrera";
		p2.genero = "Mujer";

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 09 - MÉTODOS Y USO DEL THIS EN JAVA 
|  VIDEOS: 49, 50, 51, 52, 53 
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Métodos (Video 49, 50, 51, 52).

	Los métodos son funciones o procedimientos que se definen dentro de una clase. 
	
	En la declaración de un método, se indica información como: 
	
		- Tipo del valor de retorno y si no devuelve valor, se utilia la palabra reservada "void".
		- Nombre del método, que suele ser una acción, como "insertarPersona", "borrarAlumno", etc. 
		- Número y el tipo de sus argumentos (pueden ser tipos primitivos o de tipo object, incluyendo los que nosotros creemos). Primero, 
		se indica el tipo y posteriormente el nombre del argumento separados por el caracter "," y si el método no tiene argumentos, pues
		se indica "()".
		- La visibilidad del método de cara al exterior.
		- Cuerpo del método con la funcionalidad que va a tener el método. Si el método devuelve un valor, para devolverlo hay que utilizar
		la palabra reservada "return" seguida del valor a regresar.
	
	Un ejemplo de declaración de un método con dos variables como argumentos sería:
		
		"Tipo" + "nombreMetodo" + "(" + "tipo_args1" + "nombre_args1" + "," + "tipo_args2" + "nombre_args2" + ")"
		{
			// Código del método.
		}
	
		int sumar(int a, int b)	// Éste metodo "sumar" va a devolver un valor entero y se va a pasar como argumentos dos variables enteras.
		{
			return a + b;
		}
	
	Una vez que hemos declarado un método a una clase, podemos hacer uso de él haciendo lo siguiente:
	
		- Debemos declarar un objeto del tipo de la clase que tiene el método que nos interesa utilizar.
	
			TipoClase objeto = new TipoClase();
	
		- Por medio del objeto declarado, utilizamos el operador punto "." y posterior a este operador escribimos el nombre del método 
			que nos interesa llamar.
		- Posterior del nombre del método, abrimos y cerramos paréntesis. Si el método no recibe ningún argumento, solo abrimos y cerramos
			paréntesis, sin embargo si el método fue escrito para recibir argumentos, debemos proporcionar los argumentos del tipo esperado,
			separando por comas cada uno de ellos.
		- Finalmente, si el método fue escrito para regresar un valor, es opcional el recibirlo con una variable del tipo que regresa el 
			método.
	
			tipoDevuelto resultado = objeto.nombreMetodo(arg1, arg2, etc);

2. Uso del operador "this" (Video 53) -> Continua Sección 14.

  - Palabra reservada "this".

    La palabra "this" es un operador que nos permite acceder a los atributos o métodos del objeto actual (la clase con la cual estamos trabajando). 
    
    Sus usos son:

      - Es útil para evitar la ambigüedad entre las variables de clase y las locales.
      - Es una referencia implícita al objeto que se está ejecutando.
      - Permite a un objeto enviarse a él mismo como parámetro.

    La palabra reservada "this" tiene una serie de usos y son:

    1) Evitar la ambigüedad entre las variables de clase y las locales.

      Con este operador podemos hacer una diferencia entre los argumentos recibidos en un método y los atributos de una clase.
    
      Aunque el uso del operador "this" en ocasiones parecerá redundante, es un buena práctica el usarlo para hacer referencia a los
      atributos de la clase en la que estamos trabajando, ya que al leer nuestro código rápidamente reconoceremos qué variables son
      atributos de una clase y cuales no lo son.
    
      Por ejemplo, si tenemos un código que tiene dos atributos llamados "a" y "b", y también tenemos un constructor de la clase que 
      recibe dos argumentos llamados también "a" y "b". Para hacer diferencia entre estas dos variables (atributos de la clase y los 
      argumentos recibidos en el método) ya que se llaman igual pues podemos utilizar la palabra "this" para así indicar que la variable
        que va a ir con el operador "this" va a ser el atributo de la clase y no uno de los argumentos del método. Un ejemplo sería:

      Su estructura es:
    
        "this" + "." + "nombreAtributo"
        
      // Constructor con dos argumentos. 
    
      Aritmetica (int a, int b)
      {
        // Asignación de los valores de los argumentos a los atributos.
    
        this.a = a;
        this.b = b;
      }
        
      // Creación del objeto.
    
      public static void main (String[] args)
      {
        Aritmetica obj1 = new Aritmetica (5, 8);
        obj1.sumar();
      }

      En éste caso, se utiliza el operador "this" para que los valores 5 y 8 pasado como argumentos del método y que se llaman "a" y "b" 
      se puedan cargar a los atributos de la clase "a" y "b" sin que haya confusión con respecto a tener el mismo nombre y no saber a que
      tipo de variable se esta cargando de las dos.

    2) Referencia implícita al objeto que se está ejecutando.

      En este caso, el operador "this" se puede utilizar para hacer referencia al objeto de la clase que se esté ejecutando en ese momento
      ya que por ejemplo, en el constructor "Persona" que posee el argumento "nombre", se utiliza el operador "this" primeramente para 
      distinguir el valor del atributo con el valor del argumento. 
      Luego, se vuelve a utilizar dicho operador para pasar como argumento el valor actual que tiene el atributo de la clase "Persona" y 
      va a ser ahora el valor que tendrá el argumento del método "Imprimir". 
      Por último, utilizamos el operador "this" en la clase "Imprimir" para que se observe que ahora toma el valor del atributo de la 
      clase en la que se encuentra ahora, en este caso el valor "Alfonso" y ya no toma el valor que tenía en la clase "Persona".
      
      package Sección16_Uso_This;
    
      public class PalabraThis 
      {
        public static void main (String[] args)
        {
          Persona p = new Persona ("Juan");
        }
      }
    
      class Persona
      {
        String nombre;
    
        Persona()
        {}
        
        Persona (String nombre)
        {
          this.nombre = nombre;				// Se está almacenando en el atributo de la clase "Persona" el valor del argumento "nombre".
          Imprimir imp = new Imprimir();
          imp.imprimir(this.nombre); 	// Se está pasando el valor actual que tiene el atributo de la clase "Persona" a la clase "Imprimir".
        }
      }
    
      class Imprimir
      {
        String nombre = "Alfonso";
        
        public void imprimir(String nombre)
        {
          System.out.println("Imprimir argumento: " + nombre);
          System.out.println("Imprimir objeto actual: " + this.nombre);	// Se está guardando el valor actual del atributo de la clase 
                                                                        // "Imprimir" y no el valor de la clase "Persona", ya que ahora 
                                                                        // está situado en la clase "Imprimir" y hace referencia a dicha 
                                                                        // clase.
        }
      }

    3) Permite a un objeto enviarse a él mismo como parámetro.

      package Sección16_Uso_This;
    
      public class PalabraThis 
      {
        public static void main (String[] args)
        {
          Persona p = new Persona ("Juan");
        }
      }
    
      class Persona
      {
        String nombre;
    
        Persona()
        {}
        
        Persona (String nombre)
        {
          this.nombre = nombre;	// Se está almacenando en el atributo de la clase "Persona" el valor del argumento "nombre".
          Imprimir imp = new Imprimir();
          imp.imprimir(this); 	// Se está pasando el objeto completo actual de la clase "Persona" a la clase "Imprimir".
        }
      }
    
      class Imprimir
      {
        public void imprimir(Object nombre)
        {
          System.out.println("Imprimir argumento: " + nombre);	// El objeto completo que existe ahora mismo en ésta variable es el 
                                                                // objeto de la clase "Persona" ya que se ha pasado por argumentos.
          System.out.println("Imprimir objeto actual: " + this);	// Se está guardando el valor actual del objeto de la clase "Imprimir"
                                                                  // y no el de la clase "Persona", ya que ahora está situado en la clase
                                                                  // "Imprimir" y hace referencia a dicha clase.
        }
      }
      
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 10 - CONSTRUCTORES EN JAVA 
|  VIDEOS: 54, 55 
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Constructores.

	1.1. Constructor vacío (Video 54).

		Es un tipo de método en el cual podemos inicializar los atributos de una clase siempre en el momento de la creación de un objeto, por 
		lo que podriamos crear un objeto con unos valores ya indicados en el momento de crearlo.
		
		Los constructores tienes una serie de características:
		
			- Debe de tener el mismo nombre que el nombre de la clase.
			- Estos métodos sólo se puede ejecutar al momento de la creación de un objeto, no es posible utilizarlos después.
			- Un constructor a diferencia de un método, no tiene un valor de regreso, por ello no encontraremos la palabra "return" ni un tipo
				de retorno en la declaración del constructor.
			- El nombre del constructor es idéntico al nombre de la clase, así es como podemos identificar si una clase tiene constructores.
			- Por defecto en Java, se crea un constructor sin argumentos, conocido como constructor vacío. Este constructor lo agrega en
				automático el compilador de Java a nuestra clase, sin embargo si nosotros definimos un constructor distinto al constructor
				vacío, es decir, con argumentos, entonces Java ya no agrega el constructor vacío y es nuestra responsabilidad agregar el
				constructor vacio a nuestra clase si fuera necesario por lo que hay que crear siempre el mismo método pero de tipo constructor 
				vacio.
			- El constructor vacio es necesario para crear un objeto, recordemos la sintaxis básica general para crear un objeto.
			- Por lo que ahora ya podemos entender que después de la palabra "new" realmente lo que estamos colocando es el nombre del 
				constructor que deseamos llamar, pudiendo tener argumentos o no.
			
		La estructura de un constructor es:
		
		NombreClase + (arg1, args2, etc)
		{
			// Código del constructor de la clase.
		}
		
		Por ejemplo, supongamos que tenemos dos atributos en nuestra clase, de tipo entero, llamado a y b. En el primer caso estamos creando 
		un objeto llamando al constructor vacío, por lo tanto los valores de nuestros atributos se inicializan con los valores por "default" 
		según el tipo de cada atributo. Si es un tipo primitivo, se inicializan según su valor por "default", y si son de tipo object su valor
		inicia es "null".
		
			Ejemplo de constructor vacio.
		
				- Declaración: 
		
					Aritmetica()
					{
						// Código del constructor de la clase.
					}
		
				- Llamada: Aritmetica var1 = new Aritmetica(); 
	
	1.2 - Constructor con argumentos (Video 55).
		
		Por otro lado, creamos un objeto Aritmetica pero con valores iniciales desde el momento en que estamos creando el objeto respectivo. 
		Estamos enviando los valores de 5 y 10 respectivamente, y por lo tanto podemos tomar estos valores para inicializar los atributos de
		nuestra clase.
		
		Ejemplo de constructor no vacio.
	
			- Declaración:
	
				Aritmetica (int a, int b)
				{
					// Código del constructor de la clase.
				}
	
			- Llamada: Aritmetica var1 = new Aritmetica(5, 10);

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 11 - ALCANCES DE LAS VARIABLES EN JAVA 
|  VIDEOS: 56, 57 
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Alcance de las variables (Video 56).

- Variables de clase: Variable definida como atributo de una clase que existe durante todo el tiempo que exista el objeto.

	- Pueden usarse en cualquier metodo de la clase.
	- Se inicializan con valores por default de manera automática.
	- Las variables locales, ocultan a las variables de clase, y si queremos utilizar las variables de clase en un método que ha 
		definido variables locales con el mismo nombre, entonces debemos utilizar el prefijo "this" para poder acceder a las variables
		de clase en lugar de los atributos locales.

- Variables locales: Variable definida dentro de un método, incluyendo los argumentos que recibe una función. 

	- Estas variables se crean en el momento de ejecutarse el método y se eliminan cuando termina la ejecución de dicho método.
	- Se pueden usar sólo en el método que se definen.
	- Siempre se deben de inicializar con algun valor, de lo contrario el compilador marcará un error.

Un ejemplo del alcance de las variables sería:

	public class Aritmetica
	{
		
		// Declaración de variables de clase.
		
		int a;
		int b;
	
		// Los argumentos también son variables locales del método.
	
		int sumar(int args1, int args2)		
		{
			int resultado = args1 + args2;	// Declaración de variables locales.
			return resultado;
		}
	}

2. Memoria Stack y Memoria Heap (Video 57).

	- Memoria Stack: Se utiliza para almacenar las variables locales y las llamadas de funciones en Java. Las variables almacenadas en 
					 este espacio de memoria normalmente tienen un periodo de vida corto, únicamente mientras termina la función o método 
					 en el que se están ejecutando.

	- Memoria Heap: Se utiliza para almacenar los objetos Java, incluyendo sus atributos. Los objetos almacenados en este espacio de
					memoria normalmente tienen un tiempo de duración más prolongado.

	Esto quiere decir que las varibles de tipo Object que creamos, no almacenan la información del objeto en sí mismo, sino que sólo 
	guarda la dirección de memoria de donde se encuentra la información de dicho objeto.
	
	Esto es muy importante para temas como la recolección de objetos en Java, debido a que el recolector de basura únicamente podrá 
	eliminar los objetos que no estén siendo apuntados por ninguna variable, como por ejemplo las variables declaradas de tipo Object que
	tengan como valor "Null". De esta manera el recolector de basura (garbage collector) puede buscar aquellos objetos en la memoria heap
	que ya no estén siendo referenciados por ninguna otra variable (Valor Null) y finalmente liberar el espacio en memoria que ocupaba 
	dicho objeto.

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 12 - PASO POR VALOR Y POR REFERENCIA EN JAVA 
|  VIDEOS: 59, 60 
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Paso por valor (Video 59). 

	Envío de valores a los métodos como argumentos utilizando tipos primitivos ya que sólo estamos copiando el valor del tipo primitivo a una 
	variable local del método. Esta opción funcionaría como la opción parametro "IN" en Oracle, ya que sólo su valor es de entrada.

	Ejemplo:

	// Programa principal.

	public static void main (String[] args)
	{
		int x = 10;
		imprimir(x);	// Imprime el valor 10.
		cambiarValor(x);
		imprimir(x);	// Imprime el valor 10.
	}

	// Método cambiarValor.

	public static void cambiarValor(int i)
	{
		i = 200;
	}

	En este caso, como el tipo de variable que se envía al método es primitiva y no un objeto, pues se envía una copia del valor que 
	tiene la variable, pero si se quiere modifica el valor desde otro método, el valor original de la variable no se modifica nunca ya 
	que solo se pasa una copia de ella, por lo que la variable "x" sigue teniendo el valor 10 aunque en el método se haya cambiado el 
	valor de la variable "i" a 200.

2. Paso por referencia (Video 60). 

	Envío de valores a los métodos como argumentos utilizando tipos Objetos en vez de tipos primitivos. 
	Esta opción funcionaría como la opción parametro "IN OUT" en Oracle, ya que su valor es de entrada y salida.
	
	Ejemplo:

	// Programa inicial.

	public class PasoReferencia 
	{
		public static void main (String[] args)
		{
			PasoReferenciaPersona p = new PasoReferenciaPersona();
			p.cambiarNombre("Juan");
			p.imprimirNombre(p);		// Imprime Juan.
			modificarPersona(p);
			p.imprimirNombre(p);		// Imprime Carlos ya que al pasar por referencia se puede modificar el valor de los atributos.
		}
		
		// Método interno de la clase PasoReferencia para que se observe que también se puede crear métodos dentro de una clase donde está
		// el método "main". En el caso de tener el método en la misma clase, no hay que referirse al método con el objeto "p", sino
		// que se puede acceder sin ningun problema de forna simple indicando el nombre del método y sus argumentos.
		
		public static void modificarPersona(PasoReferenciaPersona args)
		{
			args.cambiarNombre("Carlos");
		}
		
	}

	// Métodos en la clase llamada "Persona".

	public class PasoReferenciaPersona 
	{
		// Declaración de atributos.
		
		String nombre;
		
		// Declaración de métodos.
		
		public void cambiarNombre(String nuevoNombre)
		{
			this.nombre = nuevoNombre;
		}
		
		public String obtenerNombre()
		{
			return this.nombre;
		}
		
		public void imprimirNombre(PasoReferenciaPersona args)
		{
			System.out.println("Nombre: " + args.obtenerNombre());
		}
	}

	En éste caso, no se envía una copia de la información como en los tipos primitivos, sino que se está enviando la referencia al 
	objeto, por lo que vamos a poder tener acceso y modificar los atributos del objeto y que luego al terminar el código del método, 
	dichos cambios se hayan guardado en el objeto en sí pasado por argumento.

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 13 - PALABRA RETURN Y NULL EN JAVA 
|  VIDEOS: 61
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Palabra reservada "Return" (Video 61).

	Existen 3 opciones para poder regresar de un método al que fue llamado:

		1) Utilizando la palabra reservada "return".
	
			Una vez que se ejecuta esta instrucción, se regresa el control al método que hizo la llamada previa devolviendo un valor, el cual
			tiene que ser el mismo tipo que el tipo definido en la declaración del método.
					
			- Return de tipos primitivos.
		
				// Llamada al método.
	
				int resultado = sumar(6, 8);		// Devuelve un valor de tipo "int" por lo que la variable resultado tiene que ser de tipo "int".
	
				// Método llamado.
	
				int sumar(int a, int b)		// Se indica con el "int" antes del nombre del método, que el valor retornado será de tipo "int".
				{
					return a + b;
				}
	
			- Retun de tipo Objeto.
	
				// Clase Suma.
	
				public class Suma
				{
					
					int a;
					int b;
					
					// Constructor Suma vacío.
	
					public Suma()
					{}
	
					// Constructor Suma con dos argumentos.
	
					public Suma(int a, int b)
					{
						this.a = a;
						this.b = b;
					}
				}
	
				// Clase que ejecuta.
	
				public class PalabraReturn
				{
	
					public static void main (String[] args)
					{
	
						int resultado = 0;
	
						Suma sum = crearObjetoSuma();		// Devuelve un valor de tipo "Suma" por lo que la variable sum tiene que ser de tipo "Suma".
						resultado = sum.a + sum.b;
						System.out.pintln("Resultado: " + resultado);
					}
	
					// Se indica con el "Suma" antes del nombre del método, que el valor retornado será de tipo "Suma".
	
					public static Suma crearObjetoSuma()	
					{
						Suma s = new Suma(3, 4);
						return s;
					}
	
				}
	
		2) Llegando hasta el final del método:
	
			En este caso, no hay necesidad de colocar la palabra "return" de manera obligatoria, sino que una vez que se llega al final del 
			método, se hace "return" de manera implícita y con ello se obtiene el mismo resultado que si colocáramos la palabra "return" sin 
			argumentos
	
		3) Si se produce un error.
	
			Si ocurre un error en la ejecución del método, esto provoca que el método termine de manera anormal, y ya sea que se procese esta
			excepción o no, esto provocará que la ejecución del método concluya.
			
2. Comando Null (Video 61).

	El comando "null" se utiliza para eliminar la relación que tiene la variable de tipo Objeto con el objeto al que estaba apuntando, por 
	lo que ahora, dicha variabla no apunta a ningún objeto y no podrá acceder a sus atributos o métodos propios del objeto.
	
	Si se intenta acceder a los atributos o métodos de una variable de tipo Objeto a la que se le ha asignado el valor de "null", ya al no
	tener la referencia al tipo, pues no se podría acceder a dichos métodos o atributos y mostraría un error conocido llamado 
	NullPointerExcepcion.
	
	Este comando sólo se utiliza en Java con los tipos de variables Object ya que no es posible indicar un valor nulo a una variable de 
	tipo primitivo.
	
	Como regla de buena práctica, se recomienda asignar el valor nulo a una variable de tipo Objeto cuando esta variable no vaya a usarse 
	más, para que así el "recolector de basura (método System.gc())" actue cuando sea invocado y pueda borrar aquellas variables de tipo 
	Objeto que no se usen para así liberar espaci en memoria.
	
	Ejemplo:
	
	Persona p1 = new Persona();	// Se crea un objeto de tipo "Persona."
	Persona p2 = p1;			// Se crea una variable de tipo "Persona" que apunta igualmente al objeto "Persona" por lo que las dos
								// tienen acceso a los atributos o métodos del tipo "Persona".
	
	p1 = null;		// No se va a utilizar más la referencia de la variable al tipo "Persona".

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 14 - USO DE LA PALABRA THIS EN JAVA 
|  VIDEOS: 62, 63
---------------------------------------------------------------------------------------------------------------------------------------------------|

- Palabra reservada "this" (Video 62, 63).

	La palabra "this" es un operador que nos permite acceder a los atributos o métodos del objeto actual (la clase con la cual estamos trabajando). 
	
	Sus usos son:

		- Es útil para evitar la ambigüedad entre las variables de clase y las locales.
		- Es una referencia implícita al objeto que se está ejecutando.
		- Permite a un objeto enviarse a él mismo como parámetro.

	La palabra reservada "this" tiene una serie de usos y son:

	1) Evitar la ambigüedad entre las variables de clase y las locales.

		Con este operador podemos hacer una diferencia entre los argumentos recibidos en un método y los atributos de una clase.
	
		Aunque el uso del operador "this" en ocasiones parecerá redundante, es un buena práctica el usarlo para hacer referencia a los
		atributos de la clase en la que estamos trabajando, ya que al leer nuestro código rápidamente reconoceremos qué variables son
		atributos de una clase y cuales no lo son.
	
		Por ejemplo, si tenemos un código que tiene dos atributos llamados "a" y "b", y también tenemos un constructor de la clase que 
		recibe dos argumentos llamados también "a" y "b". Para hacer diferencia entre estas dos variables (atributos de la clase y los 
		argumentos recibidos en el método) ya que se llaman igual pues podemos utilizar la palabra "this" para así indicar que la variable
	  	que va a ir con el operador "this" va a ser el atributo de la clase y no uno de los argumentos del método. Un ejemplo sería:

		Su estructura es:
	
			"this" + "." + "nombreAtributo"
			
		// Constructor con dos argumentos. 
	
		Aritmetica (int a, int b)
		{
			// Asignación de los valores de los argumentos a los atributos.
	
			this.a = a;
			this.b = b;
		}
			
		// Creación del objeto.
	
		public static void main (String[] args)
		{
			Aritmetica obj1 = new Aritmetica (5, 8);
			obj1.sumar();
		}

		En éste caso, se utiliza el operador "this" para que los valores 5 y 8 pasado como argumentos del método y que se llaman "a" y "b" 
		se puedan cargar a los atributos de la clase "a" y "b" sin que haya confusión con respecto a tener el mismo nombre y no saber a que
		tipo de variable se esta cargando de las dos.

	2) Referencia implícita al objeto que se está ejecutando.

		En este caso, el operador "this" se puede utilizar para hacer referencia al objeto de la clase que se esté ejecutando en ese momento
		ya que por ejemplo, en el constructor "Persona" que posee el argumento "nombre", se utiliza el operador "this" primeramente para 
		distinguir el valor del atributo con el valor del argumento. 
		Luego, se vuelve a utilizar dicho operador para pasar como argumento el valor actual que tiene el atributo de la clase "Persona" y 
		va a ser ahora el valor que tendrá el argumento del método "Imprimir". 
		Por último, utilizamos el operador "this" en la clase "Imprimir" para que se observe que ahora toma el valor del atributo de la 
		clase en la que se encuentra ahora, en este caso el valor "Alfonso" y ya no toma el valor que tenía en la clase "Persona".
		
		package Sección16_Uso_This;
	
		public class PalabraThis 
		{
			public static void main (String[] args)
			{
				Persona p = new Persona ("Juan");
			}
		}
	
		class Persona
		{
			String nombre;
	
			Persona()
			{}
			
			Persona (String nombre)
			{
				this.nombre = nombre;				// Se está almacenando en el atributo de la clase "Persona" el valor del argumento "nombre".
				Imprimir imp = new Imprimir();
				imp.imprimir(this.nombre); 			// Se está pasando el valor actual que tiene el atributo de la clase "Persona" a la clase "Imprimir".
			}
		}
	
		class Imprimir
		{
			String nombre = "Alfonso";
			
			public void imprimir(String nombre)
			{
				System.out.println("Imprimir argumento: " + nombre);
				System.out.println("Imprimir objeto actual: " + this.nombre);	// Se está guardando el valor actual del atributo de la clase 
																				// "Imprimir" y no el valor de la clase "Persona", ya que ahora 
																				// está situado en la clase "Imprimir" y hace referencia a dicha 
																				// clase.
			}
		}

	3) Permite a un objeto enviarse a él mismo como parámetro.

		package Sección16_Uso_This;
	
		public class PalabraThis 
		{
			public static void main (String[] args)
			{
				Persona p = new Persona ("Juan");
			}
		}
	
		class Persona
		{
			String nombre;
	
			Persona()
			{}
			
			Persona (String nombre)
			{
				this.nombre = nombre;	// Se está almacenando en el atributo de la clase "Persona" el valor del argumento "nombre".
				Imprimir imp = new Imprimir();
				imp.imprimir(this); 	// Se está pasando el objeto completo actual de la clase "Persona" a la clase "Imprimir".
			}
		}
	
		class Imprimir
		{
			public void imprimir(Object nombre)
			{
				System.out.println("Imprimir argumento: " + nombre);	// El objeto completo que existe ahora mismo en ésta variable es el 
																		// objeto de la clase "Persona" ya que se ha pasado por argumentos.
				System.out.println("Imprimir objeto actual: " + this);	// Se está guardando el valor actual del objeto de la clase "Imprimir"
																		// y no el de la clase "Persona", ya que ahora está situado en la clase
																		// "Imprimir" y hace referencia a dicha clase.
			}
		}
    
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 15 - ENCAPSULAMIENTO Y USO MÉTODO "TOSTRING" EN JAVA 
|  VIDEOS: 64, 65, 66
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Encapsulamiento (Video 64).

	Característica que nos permite aislar o proteger los datos de nuestros objetos del acceso de otros objetos externos, para así restringir el 
  acceso directo a los atributos o métodos que no deseemos permitir, ya que el estado de un objeto (los valores actuales de cada uno de los 
  atributos del objeto) están generalmente ocultos.

	El encapsulamiento se logra aplicar a una clase a través de los llamados "modificadores de acceso". 
	Existen cuatro modificadores de acceso, pero en este apartado del curso sólo estudiaremos los dos primeros: 
	
		- Private: Permite acceder sólo desde la misma clase a los atributos o métodos marcados con éste modificador y no desde alguna otra clase. 
		- Public: Permite acceder desde cualquier otra clase a cualquier atributo o método definido con éste modificador.
		- Package o default.
		- Protected.

	Para indicar que se va a producir un encapsulamiento se va a utilizar un nuevo parámetro en el momento de declaración de atributos o métodos y 
  su estructura será la siguiente:

		modificador_de_acceso nombreMetodo/nombreAtributo (listaArgumentos);

		Ejemplos:

		- Declaración de atributo: private String nombre;
		- Declaración de método: private void getApellidos();

	En el momento de declarar un atributo como "private", ya no es posible poder modificar o consultar su valor directamente, sino que ahora se 
  necesita crear dos métodos en la clase donde se declara el atributo, para así poder obtener o modificar el valor que tiene actualmente el 
  atributo del objeto. 

	Éstos dos métodos se llaman "accessors" (se utiliza como nombre "get" o "is" si es boolean) y "mutators" (se utiliza como nombre "set") y 
  corresponden con la acción de obtener el valor y modificar el valor del atributo respectivamente.

- Interface de un objeto (Video 65).

	Conjunto de métodos públicos por cada atributo privado que puedan tanto modificar como recuperar el valor de nuestros atributos de clase. 
	Normalmente se crean dos métodos públicos por cada atributo privado, un método set y otro get.

		- Obtener el valor del atributo privado: 

			public tipoAtributoReturn getNombre_Atributo()
			{
				return nombreAtributo;
			}

			Ejemplo:
	
				public String getApellidos()
				{
					return apellidos;
				}

		- Obtener el valor del atributo privado de tipo boolean: 

			public boolean isNombre_Atributo()
			{
				return nombreAtributo;
			}

			Ejemplo:
	
				public boolean isActivo()
				{
					return activo;
				}

		- Modificar el valor del atributo privado: 

			public void setNombre_Atributo(Tipo nombreArgumento)
			{
				this.nombreAtributo = nombreArgumento;
			}

			Ejemplo:
	
				public void setDireccion(String newDireccion)
				{
					this.direccion = newDireccion;
				}

2 - Uso del método "toString()" (Video 66).

	En todas las clases debe de existir un método llamado "toString()" en el cual se debe de detallar la salida por consola de todos los atributos 
  con sus valores para que sea mas facil la visualización de los datos.
	
	El formato de declaración en la clase sería:
	
		public String toString() 
		{
			return "Clase nombreClase [atributo1: " + this.atributo1 + ", atributo2: " + this.atributo2 + ", atributoX: " + this.atributoX + "].";
		}
		
		Ejemplo:
		
			public String toString() 
			{
				return "Clase Persona [Nombre: " + this.nombre + ", Sueldo: " + this.sueldo + ", Eliminado: " + this.eliminado + "].";
			}
			
	La llamada a este método desde el método "main" sería:
	
		System.out.println("Datos nombreVariableObjeto con toString: " nombreVariableObjeto.toString());
		
		Ejemplo: System.out.println("Datos Persona1 con toString: " + persona1.toString());
		
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 16 - CONTEXTO ESTATICO EN JAVA 
|  VIDEOS: 67, 68
---------------------------------------------------------------------------------------------------------------------------------------------------|

- Contexto estático (Video 67).

	El contexto estático es cuando se produce la carga de las clases.
	Los atributos o métodos que se definan con la palabra "static" se van a asociar con la clase en sí y no con el objeto de la clase.
	Por lo tanto, estos atributos o métodos pueden ser accedidos desde cualquier objeto, ya que la información no se va a asociar con los objetos, 
	sino con la clase directamente.
	
	- Declaración de un atributo estático.
	
		static + tipo + nombreVariable;
		Ej: static int contadorPersonas;
		
	- Uso de un atributo estático en una definición de una clase.
	
		nombreClase.nombreVariableEstática;
		Ej: Persona.contadorPersonas = 0;
	
	- Declaración del constructor con un atributo estático.
	
		nombreClase.nombreVariableEstática = valor;
		
		Ejemplo: public Persona(String nombre, int contadorPersonas)
				 {
					
					this.nombre = nombre;
					Persona.contadorPersonas = contadorPersonas;
				 }
			
	- Declaración de los métodos get y set para un atributo estático.
	
		// Al ser un atributo estático, el método get debe de ser también estático.
		public static int getContadorPersonas()
		{
			// Al ser un atributo de clase de tipo estatico, no se puede utilizar la palabra "this" sino el nombre de la clase.
			return Persona.contadorPersonas;
		}
		
		// Al ser un atributo estático, el método set debe de ser también estático.
		public static void setContadorPersonas(int contadorPersonas)
		{
			// Al ser un atributo de clase de tipo estatico, no se puede utilizar la palabra "this" sino el nombre de la clase.
			Persona.contadorPersonas = contadorPersonas;
		}

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 17 - HERENCIA EN JAVA 
|  VIDEOS: 70, 71, 72, 73, 74
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Herencia (Video 70).

	- La herencia en Java significa que en una jerarquía de clases nos permite heredar características entre una clase Padre y una seria de clases 
    Hijas.
	- La herencia nos permitirá representar características o comportamiento en común entre clases, permitiendo definir en la clase Padre los 
    atributos o métodos que sean comunes a las clases hijas, las cuales heredarán estos atributos o métodos definidos en la clase Padre y asi 
    evita duplicar el código entre la clase Padre y las clases Hijas.
	
2. Declaración de atributos (Video 70).
	
	Para que una clase hija pueda tener acceso a un atributo de la clase padre, el atributo en la clase padre debe de estar declarado con la palabra 
	reservada "protected". Esta palabra es igual que la palabra "private" pero solo que da acceso a las clases hijas a este atributo, en cambio con 
  la palabra "private" no tendría acceso ninguna clase que no fuera en la que se define.
	
	Ej: protected String nombre;
	
3. Declaración de una clase hija (Video 71).

	Para indicar que una clase es hija de otra, se debe de utilizar la palabra "extends" en la declaración de la clase e indicar el nombre de la 
  clase que es padre de ésta.
	
	Ej: La clase Empleado es hija de la clase Persona: public class Empleado extends Persona {}
	
	Una vez que se indica que una clase es hija de otra, utilizando la palabra reservada "this" dentro de la clase hija se puede acceder a todos 
  los atributos si tienen en la clase padre el indicativo "protected" y a todos los métodos al declararse como "public" de la clase padre.
	
4. Modificar o inicializar atributos de una clase padre desde una clase hija. (Video 72).

	Para poder acceder a los atributos de una clase padre desde una clase hija para poder inicializar o modificar sus valores se debe de utilizar
  la palabra reservada "super()" en el constructor de la clase hija pasandole por argumento aquellos atributos que queramos tener acceso. 
	
	Importante: el uso de la palabra "super()" siempre se debe de realizar como primera línea de código del constructor ya que sino se produce un
  error.
	
	Con la palabra reservada "super()", lo que se está realizando internamente es una llamada al constructor de la clase padre y se sabe a que 
	constructor llama según el número de parámetros que se le pase en dicha llamada en el constructor de la clase hija y que corresponda con los 
	parámetros que tiene asociado el constructor en la clase padre.
	
	Ejemplo: 
	
	// Clase Padre "Persona".
	
		// Declaración del constructor para inicializar sólo el atributo de clase "nombre".
		
		public Persona(String nombre)
		{
			this.nombre = nombre;
		}
		
	// Clase Hija.
	
		// Declaración del constructor que carga el atributo "nombre" de la clase padre "Persona" y los atributos "idEmpleado" y "sueldo" de la clase 
    // "Empleado".
		
		public Empleado(String nombre, double sueldo)
		{
			
			// Inicializa el atributo "nombre" de la clase padre "Persona" con el valor que se pase en el argumento "nombre".
			super(nombre);
			
			Empleado.contadorEmpleado++;
			
			// Se incrementa la variable para el contador de empleados y se asigna su valor al atributo "idEmpleado".
			this.idEmpleado = Empleado.contadorEmpleado;
			this.sueldo = sueldo;
		}
	
	// Creación de un objeto de clase "Empleado" modificando el valor del atributo "nombre" de la clase padre "Persona" desde la clase hija 
  // "Empleado": 
	
		Empleado empleado1 = new Empleado("Alfonso", 1450.00);
		
5. Uso del método "toString()" de la clase Padre en la clase Hija (Video 72).

	Para poder usar el método toString() que existe en la clase padre y poder usarlo en la clase hijo para ver la información de los atributos de la 
  clase padre se debe de realizar el siguiente comando: 
	
		super.toString()
		
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 18 - SOBRECARGA DE CONSTRUCTORES Y DE MÉTODOS EN JAVA 
|  VIDEOS: 76, 77
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Sobrecarga de constructores (Video 76).

	Consiste en tener varios constructores creados en una clase pero que se diferencian entre ellos por el número de argumentos que tiene la llamada
	y el número de atributos de clase a los que afecta dicho constructor.
	
	- Llamada desde un constructor de una clase a otro constructor de la misma clase.

		Para poder llamar desde un constructor, por ejemplo, con un argumento a otro constructor de la misma clase, por ejemplo el constructor vacío,
    se utiliza la palabra "this()" indicando los argumentos que tenga el constructor.
		
		Ejemplo:
		
			// Declaración del constructor vacío.
			
			public Empleado() 
			{
				
				// Se realiza la operación de contador de los empleados.
				
				// Se incrementa la variable para el contador de empleados.
				Empleado.contadorEmpleado++;
				
				// Se asigna el valor del contador al atributo de clase "idEmpleado".
				this.idEmpleado = Empleado.contadorEmpleado;	
			}
			
			// Declaración del constructor para los atributos de clase.
			
			public Empleado(double sueldo)
			{
				
				// Se llama al constructor vacío de Empleado para que realice la carga del atributo de clase "idEmpleado".
				this();
				
				this.sueldo = sueldo;
			} 
		
		Si se utiliza la sobrecarga de constructores y en uno de ellos hay una llamada a la clase padre con la palabra "super()", esta llamada ya no
    es válida y solo se podrá utilizar el operador "this.nombreAtributo" para poder acceder al atributo de la clase padre, siempre y cuando en 
    la definición del atributo de la clase padre se haya indicado el operador "protected" para que tengan acceso con "this()" desde las clases 
    hijas a los atributos de la clase padre.
	
2. Sobrecarga de métodos (Video 77).

	Consiste en tener varios métodos llamados iguales creados en una clase pero que se diferencian entre ellos por el número de argumentos que 
  tienen y si tienen los mismos números de argumentos, deben de ser los argumentos de distinto tipo, al menos, uno de ellos, con respecto al 
  método anterior.
  Tambien, el tipo de valor de retorno puede ser el mismo o distinto entre ellos, solo influye el tema del tipo y numero de argumentos del método.
	
	Ejemplo:
	
		// Declaración del método sumar con dos argumentos de tipo entero.
		public int sumar(int a, int b)
		{
			System.out.println("Se ejecute el método sumar(int a, int b).");
			return a + b;
		}
	
		// Declaración del método sumar con dos argumentos de tipo double.
		public double sumar(double a, double b)
		{
			System.out.println("Se ejecute el método sumar(double a, double b).");
			return a + b;
		}
		
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 19 - PAQUETES EN JAVA 
|  VIDEOS: 78
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Paquetes (Video 78).

	Para poder utilizar un metodo o un atributo que existe en una clase que está en un paquete distinto al que nosotros estamos trabajando se 
  utiliza la palabra import.
	
	La palabra import lo que hace es acceder a las clases de la ruta que se indican:
	
		- Importar una clase determinada que contiene un paquete: import Pruebas.persona;
		- Importar todas las clases que contiene un paquete: import Pruebas.*;
		- Importar un método o atributo que se ha declarado como estático: import static Pruebas.persona.imprimir;
		
	Tambien, se puede usar un método o atributo que exista en una clase sin utilizar la palabra "import" sino que para utilizarlo, se tendría que
	indicar toda la ruta de paquetes, la clase y el método a utilizar (Esto no es recomendable). 
  
    Ej: Bloque01_Fundamentos.Sección17_Herencia.Persona.getEdad()
		
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 20 - PALABRA FINAL EN JAVA 
|  VIDEOS: 79, 80
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Palabra final (Video 79).

	- Uso de la palabra final.
	
		- Variables: Evita cambiar el valor que almacena la variable por lo que hace a la variable pasar a ser una constante.
			
			Ej: public final static int MI_CONSTANTE = 1;
			
		- Métodos: Evita que se modifique la definición de un método desde una subclase.
		
			Ej: public final void imprimir()
				{
					System.out.println("Método imprimir desde Persona.");
				}
				
		. Clases: Evita que se cree una subclase.
	
			Ej: public final class Persona {}
			
2. Uso de la palabra final con Objetos (Video 80).
	
	
	Cuando se usa la palabra final en la declaración de un objeto lo que indica es que ese objeto no podemos asignarle una nueva creación de un
  objeto. Ej:
	
		final Persona persona1 = new Persona(); // La primera vez podemos crear un objeto de ese tipo de forma correcta.
		persona1 = new Persona(); // La segunda vez ya se produce un error al no poderle asignar a esa variable un nuevo objeto creado.
		
	Si esta permitido modificar el valor de los atributos de la clase utilizando el método "set()" de la propia clase.
	Ejemplo:
	
		// En la clase Persona creamos los métodos get() y set();
		
			public String getNombre() 
			{
				return this.nombre;
			}
			
			public void setNombre(String nombre)
			{
				this.nombre = nombre;
			}
		
		// En la clase de Prueba modificamos el valor del atributo de la clase final y se modifica de forma correcta.
		
			persona1.setNombre("Alfonso");
			System.out.println("Persona Nombre: " + persona1.getNombre());
			
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 21 - ARREGLOS EN JAVA 
|  VIDEOS: 81, 82, 83, 84, 85, 86
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Arreglos (Video 81).

	Un arreglo es un array o conjunto de elementos en el cual vamos a poder agregar elementos de distintos tipos ya que se pueden crear arreglos
	de tipos primitivos como int, double o arreglos de objetos de tipo Persona.
	
	Los arreglos comienzan con el primer elemento que está en la posición 0 del arreglo y se va incrementando cada vez que exista un nuevo elemento
	en el arreglo. La ultima posición del arreglo se dice que es la posición (n - 1) ya que siempre la posición, al comenzar el primer elemento
	en la posición 0, pues si tiene 7 elementos, la ultima posición sería (7 - 1) = posición 6 del arreglo.

2. Arreglo de tipo primitivo.
	
	2.1. Declaración de un arreglo de tipo primitivo.
		
		La declaración de una variable de arreglo es la siguiente:
		
			tipoVariable + nombreVariable[] = new tipoVariable[numeroElementosArreglo];
		
		- Se debe de indicar siempre en la declaración, cuantos elementos va a contener el arreglo y eso se indica entre corchetes.
		- Una vez que el arreglo tiene el nº máximo de elementos indicado en la declaración, ya no es posible de poder añadir mas elementos al arreglo
		  ya que ya ha llegado al tope de elementos en el arreglo, ya que si se intenta agregar un nuevo valor, se muestra un error. 
		
		Ejemplo: Una variable de tipo entero llamada edades que va a contener 3 elementos.
		
			int edades[] = new int[3];
			
	2.2. Modificación o inicialización de los valores de un arreglo de tipo primitivo (Video 82).
	
		Para incializar, modificar o acceder al valor de un elemento dentro del arreglo se realiza de la siguiente forma:
		
			nombreArreglo[indiceElemento] = valor;
		
		Ejemplo: Inicializar los 3 elementos de un arreglo llamado "edades" y mostarlo por consola.
		
			edades[0] = 1;
			edades[1] = 37;
			edades[2] = 39;
			System.out.println("Los elementos del arreglo 'Edades' son: " + edades[0] + ", " + edades[1] + ", " + edades[2]);
			
	2.3. Recorrer los elementos de un arreglo de tipo primitivo utilizando un bucle For (Video 83).
	
		Para poder recorrer el arreglo con un bucle For se realiza la siguiente sentencia utilizando el método "length" que nos indica el valor máximo 
    de elementos que contiene el arreglo.
		
		for(int contador = 0; contador < edades.length; contador++) 
		{
			System.out.println("- Elemento " + (contador + 1) + " posición " + contador + ": " + edades[contador]);
		}

3. Arreglo de tipo Objeto.

	3.1. Declaración de un arreglo de tipo objeto (Video 84).
	
		La declaración de una variable de tipo objeto que va a contener un arreglo es la siguiente:
		
			nombreClase + nombreVariable[] = new nombreClase[numeroElementosArreglo];
		
		- El nombre de la variable siempre tiene que ser con el nombre en plural: Ejemplo: edades, personas, coches, etc.
		
		Ejemplo: Una variable de tipo Persona llamada personas que va a contener 2 elementos.
		
			Persona personas[] = new Persona[2];
			
	3.2. Modificación o inicialización de los valores de un arreglo de tipo objeto (Video 84).
	
		Para incializar, modificar o acceder al valor de un elemento dentro del arreglo se realiza de la siguiente forma:
		
			nombreArreglo[indiceElemento] = new nombreClase(inicializarValorAtributo);
		
		Ejemplo: Inicializar los 2 elementos de un arreglo de objetos llamado "personas" y mostarlo por consola utilizando el método "toString()" de 
             la clase.
		
			personas[0] = new Persona("Alfonso");
			personas[1] = new Persona("Isabel");
			System.out.println("Los elementos del arreglo 'Personas' son: " + personas[0].toString() + ", " + personas[1].toString());
		
	3.3. Recorrer los elementos de un arreglo de tipo objeto utilizando un bucle For (Video 85).
	
		Para poder recorrer el arreglo con un bucle For se realiza la siguiente sentencia utilizando el método "length" que nos indica el valor 
    máximo de elementos que contiene el arreglo.
	
		for(int contador = 0; contador < personas.length; contador++) 
		{
			System.out.println("- Elemento " + (contador + 1) + " posición " + contador + ": " + personas[contador].toString());
		}
	
4. Inicialización de valores de un arreglo desde su definición llamado "Sintaxis resumida" tanto para tipos primitivos como tipo objeto (Video 86).

	Para poder inicializar los valores de un arreglo desde su definición se realiza de la siguiente manera:
	
		tipoVariable/nombreClase nombreArreglo[] = {valorElemento1, valorElemento2, valorElementoX};
	
	Ejemplo: Un arreglo de tipo cadena llamada "frutas" que contenga 3 elementos: String frutas[] = {"Naranja", "Platano", "Uva"};
	
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 22 - MATRICES EN JAVA 
|  VIDEOS: 87, 88, 89, 90, 91
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Matrices (Video 87).

	Una matriz es un arreglo de arreglos por lo que tiene un arreglo por cada una de las filas de la matriz y luego otro arreglo por cada una de las
	columnas de la matriz.
	
	- Para acceder a un elemento determinado de la matriz, se debe de conocer la fila y la columna en la que está en ese orden.
	- Las matrices pueden ser cuadradas (1x1, 2x2, 3x3, ..) o no ser cuadradas (1x2, 2x1, 4x2, 5x3, ...).
	- Las matrices funcionan practicamente igual que las matrices, por lo que para duda ver "Apuntes - Arreglos.txt" de la "Sección 21_Arreglos".
	
2. Matrices de tipo primitivo.
	
	2.1. Declaración de una matriz de tipo primitivo.
		
		La declaración de una variable de matriz es la siguiente:
		
			tipoVariable + nombreVariable[][] = new tipoVariable[numeroElementosFila][numeroElementosColumna];
			
		- Se debe de indicar siempre en la declaración, cuantos elementos va a contener la matriz y eso se indica entre corchetes tanto para fila como 
		  para columna.
		- Una vez que la matriz tiene el nº máximo de elementos indicado en la declaración, ya no es posible de poder añadir mas elementos a la matriz
		  ya que ya ha llegado al tope de elementos en la matriz, ya que si se intenta agregar un nuevo valor, se muestra un error. 
		
		Ejemplo: Una variable de tipo matriz de tipo entero llamada edades que va a contener 3 elementos de fila y 2 elementos de columna.
		
			int edades[][] = new int[3][2];
			
			La matriz edades seria:
			
				Esquema de la matriz "edades".
		 
		 		-------------------------
		 		| F/C |   C0   |   C1   |
		    	-------------------------
	 			| F0  | [0][0] | [0][1] |
	 			-------------------------
	 			| F1  | [1][0] | [1][1] |
	 			-------------------------
	 			| F2  | [2][0] | [2][1] |
	 			-------------------------

	2.2. Modificación o inicialización de los valores de una matriz de tipo primitivo (Video 88).
	
		Para incializar, modificar o acceder al valor de un elemento dentro de la matriz se realiza de la siguiente forma:
		
			nombreMatriz[indiceElementoFila][indiceElementoColumna] = valor;
		
		Ejemplo: Inicializar todos los elementos de una matriz (3x2) llamado "edades" y mostarlo por consola.
		
			edades[0][0] = 5;
			edades[0][1] = 7;
			edades[1][0] = 8;
			edades[1][1] = 4;
			edades[2][0] = 6;
			edades[2][1] = 1;
			
			System.out.println("Los elementos de la matriz 'Edades' fila 0 son: " + edades[0][0] + ", " + edades[0][1]);
			System.out.println("Los elementos de la matriz 'Edades' fila 1 son: " + edades[1][0] + ", " + edades[1][1]);
			System.out.println("Los elementos de la matriz 'Edades' fila 2 son: " + edades[2][0] + ", " + edades[2][1]);
			
	2.3. Recorrer los elementos de una matriz de tipo primitivo utilizando un bucle For (Video 89).
	
		Para poder recorrer la matriz con un bucle For se realiza la siguiente sentencia utilizando el método "length" que nos indica el valor máximo 
    de elementos que contiene cada uno de los arreglos que contiene la matriz.
		
		- edades.length -> Obtiene el número máximo de filas que tiene la matriz, en este caso, su valor será 3.
		- edades[fila].length -> Obtiene el número máximo de columnas que tiene cada una de las filas que tiene la matriz, en este caso, su valor 
                             será 2.
		
		for (int fila = 0; fila < edades.length; fila++) 
		{
			for (int columna = 0; columna < edades[fila].length; columna++) 
			{
				System.out.println("Los elementos de la matriz 'Edades' posición [" + fila + "][" + columna + "] es: " + edades[fila][columna]);
			}
		}
		
		// Declaración del método "toString()" en la clase Persona.
		public String toString() 
		{
			return "- Clase Persona: [Nombre: " + this.nombre + "]";
		}
		
3. Matriz de tipo Objeto (Video 91).

	3.1. Declaración de una matriz de tipo objeto.
	
		La declaración de una variable de tipo objeto que va a contener una matriz es la siguiente:

			nombreClase nombreVariable[][] = new nombreClase[numeroElementosFila][numeroElementosColumna];

		- El nombre de la variable siempre tiene que ser con el nombre en plural: Ejemplo: edades, personas, coches, etc.
		
		Ejemplo: Una variable de tipo Persona llamada personas que va a contener 2 elementos de fila y 3 elementos de columna.
		
			Persona personas[][] = new Persona[2][3];
			
	3.2. Modificación o inicialización de los valores de una matriz de tipo objeto.
	
		Para incializar, modificar o acceder al valor de un elemento dentro de la matriz se realiza de la siguiente forma:
		
			nombreVariable[indiceElementoFila][indiceElementoColumna] = new nombreClase(inicializarValorAtributo);

		Ejemplo: Inicializar todos los elementos de una matriz de objetos llamado "personas" y mostarlo por consola utilizando el método "toString()" 
             de la clase.
		
			/*	
			Esquema de la matriz no cuadrada "personas" con los valores.
			 
		 		-------------------------------------
		 		| F/C |   C0    |      C1    |  C2  |
		  	 	-------------------------------------
	 			| F0  | Alfonso |   Isabel   | Álex |
	 			-------------------------------------
	 			| F1  |   Rosa  | Mª Angeles | Javi |
	 			-------------------------------------
			*/		
			
			Persona personas[][] = new Persona[2][3];
			personas[0][0] = new Persona("Alfonso");
			personas[0][1] = new Persona("Isabel");
			personas[0][2] = new Persona("Álex");
			personas[1][0] = new Persona("Rosa");
			personas[1][1] = new Persona("Mª Ángeles");
			personas[1][1] = new Persona("Javi");
			System.out.println("Los elementos de la matriz 'Personas' son: " + personas[0].toString() + ", " + personas[1].toString());

			// Recorremos la matriz con un bucle For.
			for(int fila = 0; fila < personas.length; fila++)
			{
				for(int columna = 0; columna < personas[fila].length; columna++)
				{
					System.out.println("Los elementos de la matriz 'Personas' posición [" + fila + "][" + columna + "] es: " + personas[fila][columna]);
				}
			}

			// Declaración del método "toString()" en la clase Persona.
			public String toString() 
			{
				return "- Clase Persona: [Nombre: " + this.nombre + "]";
			}
		
	3.3. Declaración de un método que imprime todos los valores de una matriz de objetos pasada por argumento (Video 91).
		
		// Método Imprimir().
		public static void imprimir(Object matriz[][])
		{
		
			// Recorremos la matriz con un bucle For.
			for(int fila = 0; fila < matriz.length; fila++)
			{
				for(int columna = 0; columna < matriz[fila].length; columna++)
				{
					System.out.println("Los elementos de la matriz posición [" + fila + "][" + columna + "] es: " + matriz[fila][columna]);
				}
			}
		} 
		
		// Llamada del método Imprimir().
		imprimir(personas);

4. Inicialización de valores de una matriz desde su definición llamado "Sintaxis resumida" tanto para tipos primitivos como tipo objeto (Video 90).

	Para poder inicializar los valores de una matriz desde su definición se realiza de la siguiente manera:
	
		tipoVariable/nombreClase nombreMatriz[][] = {{valorFila0Columna0, valorFila0Columna1}, {valorFila1Columna0, valorFila1Columna1}, etc..};
	
	Ejemplo: Una matriz cuadrada (2x2) de tipo cadena llamada "frutas" que contenga fila 0 "Narajan" y "Limón" y en la fila 1 "Fresa" y "Zarzamora" 
           mostrar los datos por consola: 
		
		La matriz "frutas" sería:
		 
			------------------------------
			| F/C |   C0    |      C1    |
			------------------------------
			| F0  | Naranja |    Limón   |
			------------------------------
			| F1  |  Fresa  | Zarzamora  |
			------------------------------
		
		// Definición de la matriz.
		String frutas[][] = {{"Narajan", "Limón"}, {"Fresa", "Zarzamora"}};

		// Recorremos la matriz con un bucle For.
		
		for(int fila = 0; fila < frutas.length; fila++)
		{
			for(int columna = 0; columna < frutas[fila].length; columna++)
			{
				System.out.println("Los elementos de la matriz 'Frutas' posición [" + fila + "][" + columna + "] es: " + frutas[fila][columna]);
			}
		}
		
	Ejemplo: Una matriz no cuadrada (2x3) de tipo cadena llamada "frutas" que contenga fila 0 "Narajan", "Limón" y en la fila 1 "Fresa", 
           "Zarzamora", "Mora". Mostrar los datos por consola: 
		
		La matriz "frutas2" sería:
		 
	 		-------------------------------------
	 		| F/C |   C0    |      C1    |  C2  |
	   	    -------------------------------------
 			| F0  | Naranja |    Limón   |      |
 			-------------------------------------
 			| F1  |  Fresa  | Zarzamora  | Mora |
 			-------------------------------------
		
		// Definición de la matriz.
		String frutas2[][] = {{"Narajan", "Limón"}, {"Fresa", "Zarzamora", "Mora"}};

		// Recorremos la matriz con un bucle For.
		
		for(int fila = 0; fila < frutas2.length; fila++)
		{
			for(int columna = 0; columna < frutas2[fila].length; columna++)
			{
				System.out.println("Los elementos de la matriz 'Frutas' posición [" + fila + "][" + columna + "] es: " + frutas2[fila][columna]);
			}
		}

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 01 - FUNDAMENTOS - SECCIÓN 23 - DISEÑO DE CLASES EN JAVA 
|  VIDEOS: 92, 93, 94, 95, 96, 97, 98
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Diseño de clases.
	
	- UML (Unified Modeling Language): Permite crear diagramas de clases, entre otros tipos de diagramas.
	- Web para creaciones de diseño de clases: https://www.umletino.com/umletino.html
	- Para mas información sobre UML está el documento "02 - UML (Unified Modeling Language).pdf" para su consulta.
	
	En UML se indican si las clases son privadas, publicas o estatícas de la siguiente manera:
	
		* Atributo privado: Se utiliza el operador "-".
		* Atributo público: Se utiliza el operador "+".
		* Atributo estático: Se utiliza el subrayado en el nombre del atributo. 

2. Dos opciones de crear los métodos "agregarProducto()" y "calcularPrecio()".

	2.1. Opción 1: Metodo para agregar un nuevo producto.
	
		public void agregarProducto(Producto producto) 
		{
			// Recorremos el arreglo y si hay un elemento vacío, pues añade el nuevo producto y sale del bucle.
			for (int i = 0; i < this.productos.length; i++) 
			{
				if (this.productos[i] == null)
				{
					this.productos[i] = producto;
					break;
				}
			}
		}
		
	2.2. Opción 2: Metodo para agregar un nuevo producto teniendo una variable "contadorProductos" declarada como atributo de la clase (Video 95).
	
		public void agregarProducto(Producto producto) 
		{
			if(this.contadorProductos < Orden.MAX_PRODUCTOS)
			{
				productos[contadorProductos++] = productos;
			}
			else
			{
				System.out.printl("Se ha superado el máximo de productos: " + Orden.MAX_PRODUCTOS);
			}
		}
	
	2.3. Opción 1: Método para calcular el precio total de los productos vendidos.
		
		public double calcularTotal()
		{
			double totalPrecio = 0;
			
			// Recorre todo el arreglo y si existe un producto, pues suma el precio de dicho producto con los precios de los otros productos. 
			for (int i = 0; i < this.productos.length; i++) 
			{
				if (this.productos[i] != null)
				{
					totalPrecio = totalPrecio + this.productos[i].getPrecio();
				}
			}
			return totalPrecio;
		}
		
	2.4. Opción 2: Método para calcular el precio total de los productos vendidos teniendo una variable "contadorProductos" declarada como atributo 
       de la clase (Video 96).
	
		public double calcularTotal()
		{
			double totalPrecio = 0;
			
			for (int i = 0; i < this.contadorProductos; i++) 
			{
				totalPrecio = totalPrecio + this.productos[i].getPrecio();
			}
			return totalPrecio;
		}

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - PROGRAMACIÓN                                                                                                                        |
---------------------------------------------------------------------------------------------------------------------------------------------------|
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 25 - ARGUMENTOS VARIABLES EN JAVA 
|  VIDEOS: 105.
---------------------------------------------------------------------------------------------------------------------------------------------------|

Argumentos variables en Java.

  Los argumentos variables son un tipo de argumento que se le pasa a un método en el cual no se conoce cuantos argumentos del mismo tipo se le van 
  a pasar, por lo que con este tipo de argumento, puede pasar al método en una llamada 2 argumentos del mismo tipo y en otra llamada 1 o 3 
  argumentos del mismo tipo.
  
  La sintaxis del argumento variable es la siguiente:
  
    // Declaración de un método.
    private void nombre_metodo(tipoArgumentoVariable + ... + nombreArgumentoVariable){}
    
    Ej: Declaración de un método que tenga un argumento de tipo variable llamado "numeros" que sean de tipo entero:
    
      private void imprimirNumeros(int...numeros){}
      
  También, se puede utilizar en métodos que utilicen otro tipo de argumentos, pero siempre el argumento variable debe de estar declarado como ultimo 
  elemento en la declaración del método.
  
    private void nombre_metodo(tipoParametro1 nombreParametro1, tipoParametro2 nombreParametro2, tipoArgumentoVariable + ... + nombreArgumentoVariable){}
    
    Ej: Declaración de un método que tenga un argumento de tipo variable llamado "numeros" que sean de tipo entero y un argumento de tipo String 
        llamado "nombre:
        
      private void imprimirNumeros(String nombre, int...numeros){}
      
  La variable de tipo argumento variable se trata en java como si fuera un arreglo de elementos del tipo indicado en la declaración por lo que para
  poder utilizar sus valores se debe de recorrer con un bucle "for" igual que si fuera un arreglo.
  
  La llamada a un método que contenga un argumento de tipo variable, será indicando los distintos elementos que va a contener el método como argumentos
  variando la posibilidad del número de parámetros que se le pase.
  
  Ejemplo: Realizar una llamada al método "imprimirNumeros()" que la primera vez tenga 3 argumentos de tipo entero, en la segunda tenga solo 1 y en la
           tercera llamada tenga 5 argumentos, todos ellos de tipo entero.
           
           // 3 Argumentos int.
           imprimirNumeros(2, 6, 10);
           
           // 1 Argumentos int.
           imprimirNumeros(4);
           
           // 5 Argumentos int.
           imprimirNumeros(2, 3, 5, 9, 7);
           
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 26 - ENUMERACIONES EN JAVA 
|  VIDEOS: 106, 107, 108.
---------------------------------------------------------------------------------------------------------------------------------------------------|

Enumeraciones en Java (Video 106).

  Una enumeración es un tipo de variable similar a una clase que contiene varios elementos definidos dentro de ésta variable.
  
  Para declarar una enumeración, en vez de utilizar la palabra "class" como una clase normal, en este caso se utiliza la palabra "enum".
  Se puede crear un archivo de clase de tipo Enum de la siguiente manera: En el "Project Explorer", haciendo click derecho en el paquete donde va 
  a contener el archivo de clase tipo enum -> New -> Enum.

  Este tipo de clase, siempre van a ser de tipo cadena y constantes por lo que se puede entender por una clase de tipo enum que es una clase que
  contiene una lista de cadenas de tipo constante.

  A continuación, se debe de declarar los valores que va a tener la clase de tipo enumeración, van separados por comas y siempre van a ser public
  static final por lo que los valores de ese tipo siempre son constantes y se deben de declarar como tal, utilizando las mayusculas.
  
  En la declaración, los valores que va a tener la clase de tipo enumeración, van separados por comas y siempre van a ser public static final 
  por lo que los valores de ese tipo siempre son constantes y se deben de declarar como tal, utilizando las mayusculas.
  
  Tambien, los valores no se debe de indicar los valores que va a contener con comillas dobles como las cadenas normalmente, sino que se declaran
  los valores sin comillas.
    
1. Sintaxis de una clase de tipo enum.
  
  La declaración de la clase tipo enum sería: public enum nombreClaseEnum {DATO_STRING1, DATO_STRING2,.., DATO_STRING_N}

    Ej: Clase de tipo enum llamada "DiasSemana" que contenga todos los días de la semana.
  
      // Clase de tipo Enumeración llamada DiasSemana que contiene todos los días de la semana.
      public enum DiasSemana 
      {
        LUNES,
        MARTES,
        MIERCOLES,
        JUEVES,
        VIERNES,
        SABADO,
        DOMINGO
      }
    
2. Uso de una clase tipo enum.

  Para poder usar un valor de una clase de tipo enum, se debe de indicar nombre_clase_enum + . + VALOR;
  
    Ej: Imprimir el valor de Sabado utilizando la clase enum llamada "DiasSemana".
    
      System.out.println("Día de la semana: " + DiasSemana.SABADO); 
      
  Para poder utilizar todos los valores que contenga una clase de tipo enum, se puede usar un bucle de tipo "switch", en el cual, pasando la 
  variable de tipo enum, haga una acción con cada uno de los valores que contiene dicha clase enum.
  
    Ej: Crear un método llamado "indicarDiaSemana()" que imprima el día de la semana del valor de una clase enum "DiasSemana" que contenga los 
        días de la semana.
     
      public void indicarDiaSemana(DiasSemana dia)
      {
        
        switch (dia) 
        {
          case LUNES:
            
            System.out.println("Lunes: Primer día de la semana.");
            break;
            
          case MARTES:
            
            System.out.println("Martes: Segundo día de la semana.");
            break;
          
          case MIERCOLES:
            
            System.out.println("Miércoles: Tercer día de la semana.");
            break;
            
          case JUEVES:
            
            System.out.println("Jueves: Cuarto día de la semana.");
            break;
    
          case VIERNES:
            
            System.out.println("Viernes: Quinto día de la semana.");
            break;
          
          case SABADO:
            
            System.out.println("Sábado: Sexto día de la semana.");
            break;
            
          case DOMINGO:
            
            System.out.println("Domingo: Séptimo día de la semana.");
            break;
            
          default:
            
            System.out.println("ERROR: El valor introducido es erróneo.");
            break;
        }
      }      

3. Uso de clase de tipo enum con definición de atributos (Video 107).

  En una clase de tipo enum, igual que cualquier otra clase, se pueden definir atributos de clase pero en este caso particular, esos atributos
  de clase los asigna a cada uno de los valores que tiene la clase enum.
  
  - Pasos para declarar una clase enum con atributos de clase.
  
    1) En la declaración de la clase de tipo num, se debe de indicar cada uno de los valores y éstos tienen entre paréntesis los valores
       de los atributos de clase que va a contener la clase tipo enum.
    
    2) Se debe de declarar los atributos de la clase tipo enum.
    3) Se debe de declarar el constructor de la clase para asignar el atributo de clase.
    4) Se debe de definir los métodos get() y set() de los atributos de clase.
  
      Ej: Declarar una clase de tipo enum llamada "Continentes" que contenga los 5 continentes y en cada uno se le indique el número de
          paises que tiene cada continente.
      
        // Declaración de la clase enum llamada "Continentes".
        public enum Continentes 
        {
          // Se indica el valor del atributo de clase que va a tener cada uno de los elementos de la clase enum "Continentes".
          AFRICA(53),
          EUROPA(46),
          ASIA(44),
          AMERICA(34),
          OCEANIA(14);
          
          // Declaración de un atributo de clase que tiene cada uno de los valores de la clase enum.
          private final int numPaises;
          
          // Definición del constructor que carga el valor que se le pasa por parámetro a cada valor de la clase enum "Continentes".  
          Continentes(int numPaises)
          {
            this.numPaises = numPaises;
          }
          
          // Definición del método get() del atributo de clase.
          public int getNumPaises()
          {
            return this.numPaises;
          }
        } 
            
  - Uso de una clase de tipo enum que contiene atributos en cada uno de sus elementos (Video 108).
  
    Para poder usar uno de los valores de la clase enum, como hemos visto antes, se indica el nombre de la clase enum + . + valor pero para
    poder acceder al valor del atributo de la clase se realiza utilizando el método get() ya que funciona igual que una clase normal.
    
      Ej: Se muestra por pantalla el nombre del 4º continente de la clase enum "Continentes", en este caso, "AMERICA" y que tambien se 
          muestre el número de paises que tiene.
    
        System.out.println("El 4º continente es " + Continentes.AMERICA + " y tiene " + Continentes.AMERICA.getNumPaises() + " paises.");

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 27 - BLOQUES DE CÓDIGO EN JAVA 
|  VIDEOS: 109, 110.
---------------------------------------------------------------------------------------------------------------------------------------------------|

Bloques de inicialización de código en Java (Video 109).
	
	Los bloques de inicialización de código son "bloques anónimos" que se utilizan para inicializar variables.
	Este bloque de código se ejecuta antes de la llamada al constructor de la clase en la que se encuentre.
	
	
	Existen dos tipos de bloque de inicialización:
	
		- Bloque de inicialización estático: 
			
			* Se ejecuta una unica vez cuando se carga la clase en memoria.
			* Se ejecuta antes del constructor y de un bloque de inicialización estático.
			* Sólo se pueden inicializar variables que sean declaradas de tipo estáticas con la palabra "static".
			
		- Bloque de inicialización no estático.
			
			* Se ejecuta cada vez que se cree un nuevo objeto de la clase.
			* Se ejecuta antes del constructor y después de un bloque de inicialización estático si hubiera.
			* No se puede inicializar variables estáticas sino variables no estáticas.
			* Veo que es útil para usarlo cuando hay que inicializar una variable tipo "idPersona" con una variable contador "contadorPersona" de forma
				automática.
		
1) Bloque de inicialización estático.
	
	Se define con la palabra "static" y el uso de llaves.
	
	static
	{
		codigo_inicialización_estatico;
	}		

2) Bloque de inicialización no estático.
	
	Se define solo con el uso de llaves.
	
	{
		codigo_inicialización_noestatico;
	}
	
Ejemplo:

	Un ejemplo sería inicializar dos variables una estatica y otra no estática y cada uno hacer la inicialización en su
	bloque de inicialización correspondiente.
	
		public class Persona 
		{
			
			// Declaración de atributos de la clase.
			private final int idPersona;
			private static int contadorPersonas;
			
			// Declaración del bloque de inicialización de código de tipo estático.
			static
			{
				System.out.println("Ejecución del bloque de inicialización estático.");
				Persona.contadorPersonas = 1;
			}
			
			// Declaración del bloque de inicialización de código de tipo no estático.
			{
				System.out.println("Ejecución del bloque de inicialización no estático.");
				this.idPersona = Persona.contadorPersonas++;
			}
			
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 28 - USO DEL BUCLE FOREACH EN JAVA 
|  VIDEOS: 111, 112.
---------------------------------------------------------------------------------------------------------------------------------------------------|

Uso del bucle forEach en Java (Video 111).
	
	La palabra reservada "forEach" corresponde a un bucle "for" pero mejorado.
	
	- No tiene variable contador, sino que tiene una variable que va a almacenar cada uno de los elementos del arreglo y debe de ser del mismo tipo
		de dato que los elementos del arreglo.
	- Al no utilizar variable contador, no se puede tener acceso al índice de la posición en la cual está cada elemento dentro del arreglo.
		
1. Declaración y uso del bucle "forEach" para elementos primitivos.

	- La sintaxis que tiene la declaración del bucle forEach es:
	
		for (tipo_variable nombre_variable : nombre_arreglo) 
		{
			codigo;
		}
		
	- Ej: Tenemos un arreglo con varias edades y recorremos cada uno de los elementos utilizando el bucle "forEach" para mostrarlo por consola.
	
		int a_edades[] = {5, 6, 8};
		
		for (int w_edad : a_edades) 
		{
			System.out.println("Edad: " + w_edad);
		}
		
2. Declaración y uso del bucle "forEach" para elementos de tipo Objeto (Video 112).

	- La sintaxis que tiene la declaración del bucle forEach utilizando un objeto es:
	
		for (tipo_objeto nombre_variable : nombre_arreglo_objetos) 
		{
			codigo;
		}
		
	- Ej: Tenemos un arreglo con varias Personas de clase Persona y recorremos cada uno de los elementos utilizando el bucle "forEach" para 
				mostrarlo por consola.
	
		Persona a_personas[] = {new Persona("Alfonso"), new Persona("Isabel"), new Persona("Álex")};

		for (Persona w_persona : a_personas) 
		{
			System.out.println(w_persona.toString());
		}
	
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 29 - AUTOBOXING Y UNBOXING EN JAVA 
|  VIDEOS: 113.
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Definición de Autoboxing y Unboxing.
		
	- Autoboxing: Proceso que el compilador hace de manera automática para convertir un tipo primitivo en un objeto Java en su tipo Object 
								equivalente.
	- Unboxing: Proceso que el compilador hace de manera automática para convertir un objeto de tipo envolvente a un tipo primitivo sin necesidad de
						  aplicar ninguna conversión entre objetos y tipos primitivos.
						  
	Cada uno de los tipos primitivos tiene una clase asociada conocida como Clase Wrapper o clase envolvente del tipo primitivo.
	
2. Clases envolventes de los tipos primitivos.

	- Tipo primitivo int: Clase Integer.
	- Tipo primitivo long: Clase Long.
	- Tipo primitivo float: Clase Float.
	- Tipo primitivo double: Clase Double. 
	- Tipo primitivo boolean: Clase Boolean.
	- Tipo primitivo byte: Clase Byte.
	- Tipo primitivo char: Clase Character.
	- Tipo primitivo short: Clase Short.
	
	Estas clases envolventes se utilizan porque tienen atributos y métodos que se pueden utilizar a diferencia de los tipos primitivos que solo 
	declara su tipo.
	
	Si la operación que se va a realizar requiere de muchos calculos, se recomienda utilizar los tipos primitivos pero si no tiene mucha lógica de 
	calculo, podemos utilizar las clases envolventes, ya que va a ser mas recomedable decbio a que podemos utilizar incluso conversiones de manera 
	más simple.
	
3. Uso del Autoboxing para la conversión de tipos de datos utilizando las clases envolventes.

	Para convertir un dato entero de tipo Integer a los demás tipos se utilizan los siguientes métodos del objeto Integer.
	
		- int a int: objetoInteger.intValue());
		- int a long: objetoInteger.longValue());
		- int a float: objetoInteger.floatValue());
		- int a double: objetoInteger.doubleValue());
		- int a short: objetoInteger.shortValue());
		- int a byte: objetoInteger.byteValue());

	Ej: Tenemos una variable de tipo Integer llamada "numero" y se debe de convertir a todos los demás tipos de datos y mostrarlo por consola.
	
		Integer numero = 10;

		// Conversión de tipo int a otros tipos.
		
		System.out.println("int a int: " + numero.intValue());
		System.out.println("int a long: " + numero.longValue());
		System.out.println("int a float: " + numero.floatValue());
		System.out.println("int a double: " + numero.doubleValue());
		System.out.println("int a short: " + numero.shortValue());
		System.out.println("int a byte: " + numero.byteValue());

4. Uso del Unboxing.
	
	Se asigna el valor que tiene la variable de tipo Clase envolvente a la variable de tipo primitiva.
	 
		Ej: Tenemos una variable de tipo Integer llamada "enteroInt" y queremos que su valor pase a ser una variable de tipo primitiva int.
 
			Integer enteroInt = 5;
				
			// Se obtiene el valor de la variable de tipo Clase Integer y se asigna a una variable de tipo primitivo int.
			int entero2 = enteroInt; 
			System.out.println("Entero primitivo: " + entero2);

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 30 - MODIFICADORES DE ACCESO EN JAVA 
|  VIDEOS: 114, 115, 116, 117.
---------------------------------------------------------------------------------------------------------------------------------------------------|

Tipos de Modificadores de acceso.
	
	Los modificadores de acceso en Java son los siguientes en el orden del menos restrictivo al más restrictivo:
	
		- public: 
		- protected.
		- default: Es el tipo de modificador cuando no se indica ninguno por eso es el predeterminado.
		- private.
		
	Los modificadores de acceso se pueden utilizar en la declaración de los siguientes elementos:
	
		- Clase.
		- Atributo o variable.
		- Constructor.
		- Método.

	Según sea el elemento a declarar se podrá utilizar un modificador de acceso u otro y va a funcionar de una manera determinada:
	
		-------------------------------------------------------
		MODIFICADOR		CLASE		ATRIBUTO		METODO		CONSTRUCTOR
		-------------------------------------------------------
		public				 Si			   Si					Si					Si
		protected			 No			   Si					Si					Si
		default				 Si			   Si					Si					Si
		private				 No			   Si					Si					Si

1. Modificador de acceso "public" (Video 114).

	Se puede utilizar en cualquier parte de nuestro proyecto ya que siendo public se puede usar la clase desde otra clase del mismo paquete o desde
	otras clases de otros paquetes externos.
	
2. Modificador de acceso "protected" (Video 115).

	- Este tipo de modificador se utiliza cuando existen clases padre y clases hijas relacionadas.
	- No se puede utilizar en la definición de una clase.
	- Permite a las clases hijas poder acceder a los atributos, constructores y métodos declarados en la clase padre relacionada.
	- No se permite utilizar atributos de clase, constructores y métodos declarados como "protected" en otras clases que no sean clases hijas 
		relacionadas.
	- Se tiene acceso a los atributos de clase, constructores y métodos de la clase padre desde la clase hija, incluso si la clase hija se encuentra
		declarado en otro paquete distinto al de la clase padre.
		
3. Modificador de acceso "default" (Video 116).

	- Este tipo de modificador se utiliza cuando no se indica ningún tipo de modificador de acceso en una clase, atributo, constructor o método.
	- No se permite utilizar una clase declarada como default en otra clase creada en otro paquete distinto al paquete de la clase default por lo 
		que solo permite trabajar con clases que se encuentren dentro de su mismo paquete.
	- Se tiene acceso a los atributos de clase, constructores y métodos de una clase en otra clase, pero sólo si las clases se encuentran 
		declaradas en el mismo paquete.
	- Si tuviera relación padre/hija entre las clases, para poder usar los atributos, constructores y métodos de la clase padre en la clase hija,
		se deben de declarar las dos clases en el mismo paquete.
		
4. Modificador de acceso "private" (Video 117).

	- No se puede utilizar en la definición de una clase.
	- No se puede modificar el valor de un atributo de clase directamente siendo privado ya sea hijo o este en el mismo u otro paquete, sólo se 
		podrá modificar directamente desde la clase que está declarando el atributo o utilizando los métodos get() y set() declarados en ella.
	- No se puede utilizar el constructor o un método siendo privados ya sea hijo o este en el mismo u otro paquete, ya que sólo se pueden usar
		dentro de la clase donde se están declarando, nunca en otra clase.
	- Desde una clase hija, lo unico que se puede acceder es a un constructor de la clase padre que esté declarado como "public" utilizando el 
		operador "super()" ya que a uno indicando como "private" no es posible.
		
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 31 - SOBREESCRITURA DE MÉTODOS EN JAVA 
|  VIDEOS: 118, 119.
---------------------------------------------------------------------------------------------------------------------------------------------------|

Sobreescritura de métodos.

	En la sobreescritura de metodos se debe de aplicar el concepto de Herencia ya que la sobreescritura significa que un método en la clase hija va
	a modificar el funcionamiento del mismo método de la clase padre, ya que lo sobreescribe.
	
	Se debe de indicar como información que se esta sobreescribiendo un método utilizando para ello la palabra "@Override", esta palabra indica al
	compilador que es un método sobreescrito del que posee la clase padre.
	
	Para poder acceder al método propio de la clase padre se debe de utilizar el operador "super" de la siguiente manera:
	
		super.nombreMetodoPadre;
		
	Ejemplo: 
	
		Creamos un método en la clase padre:
	
			public String obtenerDetalles()
			{
				return "Nombre: " + this.nombre + ", Sueldo: " + this.sueldo;
			}
			
		Creamos el mismo método en la clase hija pero añadiendo un atributo propio de la clase hija.
		
			@Override
			public String obtenerDetalles()
			{
				
				// Se llama al método "obtenerDetalles()" de la clase padre y se concatena el valor del atributo de la clase hija.
				return super.obtenerDetalles() + ", Departamento: " + this.departamento;
			}
			
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 32 - POLIMORFISMO EN JAVA 
|  VIDEOS: 120, 121.
---------------------------------------------------------------------------------------------------------------------------------------------------|

Polimorfismo en Java (Video 120).

	Para que se pueda utilizar el concepto de polimorfismo se debe de haber aplicado antes el concepto de Sobreescritura de métodos ya que se debe 
	de aplicar el concepto de Herencia y ademas ya haber sobreescrito en la clase hija algún método de la clase padre.
	
	El polimorfismo significa tener un método general el cual puede tener multiples comportamientos según sea la referencia del objeto que se le
	pasa por argumentos. Esto solo se puede visualizar en tiempo de ejecución por lo que desde el compilador no podemos comprobar como se implementa
	este concepto, sino que unicamente hasta que ejecutamos nuestro programa, nos vamos a dar cuenta como funciona el polimorfismo.
	
	Una vez que estas dos condiciones existen, se puede aplicar el concepto de Polimorfismo que consiste en poder utilizar el mismo método declarado
	en las dos clases (padre e hija) y según el tipo de objeto que se le pase como argumento, pues va a utilizar el método creado en la clase padre
	o el método creado en la clase hija.
	
	Siempre se tiene que indicar como tipo de argumento en la llamada del método sobreescrito el tipo de la clase con mayor jerarquía, osea, si 
	tiene clase padre e hija, pues se crea de la padre, en cambio, si hubiera clase abuelo, padre, hijo, pues se crearía del tipo abuelo.
	
	El metodo que se declara en la clase hija tiene que tener como modificador de acceso el mismo que el que tiene el método de la clase padre o ser
	menos rectrictivo, pero nunca mas restrictivo que la clase padre. Por ejemplo, un método declarado en la clase padre siendo "protected", la 
	clase hija debe de ser también "protected" pero también "default" o "public" al ser menos restrictivo pero nunca podría ser "private" al ser mas
	restrictivo que el método en la clase padre.
	
	Ej: Se tiene dos clases una padre (Empleado) de la otra que es hija (Gerente) y tienen el mismo método llamado "obtenerDetalles()" que en uno 
	imprime por consola los datos de los atributos de la clase padre y en la clase hija, imprime los datos de la clase padre junto al atributo propio
	de la clase hija.
	
		// Clase Padre (Empleado).
		
		public String obtenerDetalles()
		{
			return "Nombre: " + this.nombre + ", Sueldo: " + this.sueldo;
		}
		
		// Clase Hija (Gerente).
		
		public String obtenerDetalles()
		{
			
			// Se llama al método "obtenerDetalles()" de la clase padre y se concatena el valor del atributo de la clase hija.
			return super.obtenerDetalles() + ", Departamento: " + this.departamento;
		}
		
		// Clase principal donde se crean los objetos.
		
		// Se define un método que llama al método "obtenerDetalles()".
		
		public static void imprimir(Empleado a_empleado)					// Se define un argumento de tipo objeto de la clase Padre Empleado (Mayor jerarquía).
		{
			System.out.println("Datos: " + a_empleado.obtenerDetalles());									// Se llama al método compartido entre la clase padre e hija.
		}
		
			// Creación de objeto tipo Empleado.
			
			Empleado empleado1 = new Empleado("Alfonso", 5000);
			imprimir(empleado1);															// Se llama al método "imprimir() pasando como argumento una variable tipo Empleado (Padre).
			
			// Resultado por consola: Datos: Nombre: Alfonso, Sueldo: 5000.0	// Se muestran los datos utilizando el método "obtenerDetalles()" del padre.
			
			// Creación de objeto tipo Gerente.
			
			Gerente gerente1 = new Gerente("Isabel", 2000, "Contabilidad");
			imprimir(gerente1);																// Se llama al método "imprimir() pasando como argumento una variable tipo Gerente (Hija).
			
			// Resultado por consola: Datos: Nombre: Isabel, Sueldo: 2000.0, Departamento: Contabilidad		// Se muestran los datos utilizando el método
																																																		// "obtenerDetalles()" del hijo.
																																																		
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 33 - PALABRA INSTANCE OF EN JAVA 
|  VIDEOS: 122, 123.
---------------------------------------------------------------------------------------------------------------------------------------------------|

Palabra "instanceof" (Video 122, 123).

	Instance Of significa "instancia de cierto tipo" y sirve para saber una variable de tipo objeto al tipo al que esta apuntando en memoria, ya que 
	una variable de tipo objeto puede ser de un tipo objeto en el momento de la declaración pero luego se le puede asignar un objeto de otro tipo, 
	por ejemplo, una variable de tipo objeto de una clase padre y que luego le asigne un objeto del tipo de la clase hija.
	
	Empleado empleado1 = new Empleado("Alfonso", 5000);					// Se crea un objeto de tipo clase padre "Empleado".
	empleado1 = new Gerente("Isabel", 10000, "Contabilidad");		// Se le asigna un objeto de tipo clase hija "Gerente".
	
	Para usar la palabra reservada "instanceof" se debe de realizar siempre dentro de un condicional "if" preguntando si la variable que se le pasa
	es de un tipo de objeto determinado, siempre en el orden de la clase mas abajo hacia arriba (1º Hijo -> 2º Padre -> 3º Abuelo -> .. -> Object).
	
	Esta palabra de Java se utiliza también para asegurar que una variable es de un tipo de objeto determinado porque se pueden convertir variables
	de objetos a un tipo determinado, tal y como se realiza igualmente en los tipos primitivos utilizando los () e indicando el tipo al que se quiere
	convertir la variable de forma "forzada". Con el uso de "instanceof" podemos saber exactamente el tipo que es el objeto para luego poder convertir
	dicha variable en otro tipo de otra clase, normalmente en una clase de tipo padre.
	
	Ejemplo: Crear un método llamado "determinarTipo()" en el cual se pase una variable por argumento e indique de que tipo de objeto es.
	
		// Llamada al método "determinarTipo()".
		
		determinarTipo(empleado1);
	
		// Declaración del método "determinarTipo" que nos indica a que tipo de objeto está apuntando la variable objeto que se pasa por argumento.
		
		public static void determinarTipo(Empleado empleado)
		{	
			// Se pregunta si la variable "empleado" esta apuntando en memoria a un objeto de tipo Gerente.
			if (empleado instanceof Gerente)
			{
				System.out.println("La variable es de tipo Gerente.");
				
				// Se crea un objeto de tipo gerente y se le asigna la variable "empleado" que en verdad apunta a un objeto de tipo Gerente, por lo que se 
				// convierte la variable "empleado" al tipo "Gerente" y así ya puede acceder al método get() declarado en la clase "Gerente".
				
				// Estas dos líneas se pueden resumir en una sola: ((Gerente) empleado).getDepartamento()
				
				Gerente gerente1 = (Gerente)empleado;
				System.out.println("Departamento: " + gerente1.getDepartamento());
				
			}			
			// Se pregunta si la variable "empleado" esta apuntando en memoria a un objeto de tipo Empleado.
			else if (empleado instanceof Empleado)
			{
				System.out.println("La variable es de tipo Empleado.");
			}
			// Se pregunta si la variable "empleado" esta apuntando en memoria a un objeto de tipo Object.
			else if (empleado instanceof Object)
			{
				System.out.println("La variable es de tipo Object.");
			}
			
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 34 - CONVERSIÓN DE OBJETOS EN JAVA 
|  VIDEOS: 124, 125.
---------------------------------------------------------------------------------------------------------------------------------------------------|

Conversión de objetos (Video 124, 125).
	
	Hay dos tipos de conversión de objetos según sea el nuevo nivel de jerarquía que se le vaya a asignar a la variable de tipo objeto y son:
	
	1) Downcasting: Realizar una conversión de una variable de tipo objeto que sea por ejemplo una clase padre y luego se le asigna una clase hija o 
								  una clase nieta, por lo que baja en cuanto a la jerarquía de clases.
								  Es necesario de indicar entre () la clase a la que se quiere convertir la variable de tipo objeto.
								  
								  // Declaración de variable de tipo objeto Empleado y apunta a un objeto de tipo Escritor.
								  Empleado empleado = new Escritor("Alfonso", 5000, TipoEscritura.CLASICO);
								  
								  // Se llama al método "obtenerDetalles()" y utilizará el método sobreescrito que se encuentra en la clase hijo "Escritor" ya que 
								  // la variable "empleado" tiene los datos del objeto "Escritor" y no los datos del objeto "Empleado".
									System.out.println("Datos: " + empleado.obtenerDetalles());
		
								  // Esta convirtiendo una variable objeto de tipo Empleado (Clase Padre) en una variable de tipo Escritor (Clase Hijo).
								  Escritor escritor = (Escritor) empleado;
								  
	2) Upcasting: Realizar una conversión de una variable de tipo objeto nieta y luego se le asigna una clase padre o abuelo, por lo que sube en 
							  cuanto a la jerarquía de clases.
							  No es necesario indicar entre () la clase a la que se quiere convertir la variable de tipo objeto.
							  Se tiene acceso a los métodos tanto de la clase padre como de la clase hija.
							  
							  // Caso de Upcasting: Está convirtiendo una variable objeto de tipo Escritor (Clase Hija) en una variable de tipo Empleado (Clase Padre).
								Esta sentencia: Empleado empleado2 = (Empleado) escritor; es igual a esta sentencia: Empleado empleado2 = escritor;
							  
								// Se llama al método "obtenerDetalles()" y utilizará el método sobreescrito que se encuentra en la clase hijo "Escritor" ya que 
								// la variable "empleado" tiene los datos del objeto "Escritor" y no los datos del objeto "Empleado".
								System.out.println("Datos: " + empleado2.obtenerDetalles());
								
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 35 - COMPARACIÓN DE OBJECT Y USO DE EQUALS Y HASHCODE EN JAVA 
|  VIDEOS: 126, 127.
---------------------------------------------------------------------------------------------------------------------------------------------------|

Comparar objetos (Video 126, 127).
	
	La clase object es la clase principal en Java y todas las clases que se crean heredan de la clase "Object" y esta clase tiene ya algunos métodos
	asociados como pueden ser:
	
		+ Método toString(): String
		+ Método equals(): boolean
		+ Método hashCode(): int
		  ...
		  
1. Método "equals()". 

	- Se realiza una comparación del contenido entre dos objetos y nos indica si dichos objetos son iguales.
	- Devuelve un valor "boolean".
	- Se debe de implementar éste método en la clase donde se quiera usar y para ello utilizamos la creación de métodos de forma automática: 
		Source -> Generate HashCode() and Equals()..
		
		Ejemplo:
		
			// Declaración de dos objetos de tipo Empleado.
			Empleado empleado1 = new Empleado("Juan", 5000);
			Empleado empleado2 = new Empleado("Juan", 5000);
			
			// Se comprueba si los dos objetos son iguales en contenido con el método "equals()" (Video 127).
			if (empleado1.equals(empleado2))
			{
				System.out.println("Equals: Los objetos son iguales en contenido.");
			}
			else
			{
				System.out.println("Equals: Los objetos son distintos en contenido.");
			}
			
			// Resultado: Equals: Los objetos son iguales en contenido.

2. Metodo "hashCode()". 

	- Nos permite comparar el contenido entre dos objetos pero se va a realizar la comparación con un tipo entero, por lo que se va a generar un valor
		de tipo entero y se le va a asignar a cada objeto generado a partir de los valores de cada uno de los atributos de la clase, asi que se genera 
		un entero unico para cada objeto. Posteriormente, se compara ese valor unico para saber si dos objetos son iguales.
	- Devuelve un valor "int".
	- Si se implementa el método "hashCode()" tenemos que sobreescribir el método "equals()" ya que de no hacerlo, cuando se usen algunas estructuras 
		de datos podríamos tener inconsistencias.
	- Se debe de implementar éste método en la clase donde se quiera usar y para ello utilizamos la creación de métodos de forma automática: 
		Source -> Generate HashCode() and Equals()..
		
		Ejemplo:
			
			// Se comprueba si los dos objetos son iguales en contenido con el método "hashCode()" (Video 127).
			if (empleado1.hashCode() == empleado2.hashCode())
			{
				System.out.println("HashCode: Los objetos son iguales en contenido.");
			}
			else
			{
				System.out.println("HashCode:Los objetos son distintos en contenido.");
			}
			
			// Resultado: HashCode: Los objetos son iguales en contenido.
																
Los métodos "equals()" y "hashCode()" son distintos, pero si el método "equals()" devuelve "true", el método "hashCode()" también va a devolver el 
mismo valor "true" y lo mismo pasa con el valor "false".

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 36 - CLASE ABSTRACTA EN JAVA 
|  VIDEOS: 128, 129.
---------------------------------------------------------------------------------------------------------------------------------------------------|

Clases Abstractas.
	
	- Una clase abstracta es una clase que no tienen ninguna implementación y se definen con la palabra reservada "abstract".
	- Si una clase contiene al menos un método abstracto, la clase se debe declarar también como abstracta.
	- Una clase abstracta puede contener métodos abstractos y no abstractos, además un método abstracto no tiene cuerpo, y solo termina con punto y 
		coma, de esta manera un método abstracto sólo define la firma del método pero no agrega ningún comportamiento, y son las clases hijas las que 
		se encargan de implementar este método, es decir, agregar algún comportamiento.
		De alguna manera es como la sobreescritura, sin embargo debido a que en el método padre no se ha definido ningún comportamiento en el método 
		abstracto, entonces no se dice que la clase hija sobreescribe el método heredado, sino que lo implementa.
	- No se pueden crear objetos de una clase abstracta, esto es debido a que algo abstracto no puede materializarse en un objeto, y este mismo 
		concepto aplica para los métodos abstractos, por lo que sólo podemos trabajar con clases hijas.
		
	- Declaración de una clase abstracta.
	
		modificador de acceso + abstract + class + nombreClaseAbstracta
	
	- Declaración de un método abstracto.
	
		abstract + tipoRetorno + nombreMetodoAbstracto() + ";"
		
		Ejemplo:
			
			// Declaración de la clase Padre y el método, ambos son abstractos.
			public abstract class FiguraGeometrica
			{
				abstract void dibujar();
			}
			
			// Declaración de la clase Hija y el método.
			public class Rectangulo extends FiguraGeometrica
			{
				void dibujar()
				{
					System.out.println("Se imprime un " + this.getClass().getSimpleName());	// Obtiene el nombre de la clase en la que se indica éste código.
				}
			}
	
	- Uso de un método abstracto.
	
		// Uso de Upcasting, ya que se crea una variable de tipo padre "FiguraGeometrica" pero apunta a un objeto de tipo hijo "Rectangulo".
		FiguraGeometrica figura = new Rectangulo("Rectángulo");																																	 
		
		// Uso de Polimorfismo, ya que utiliza el método de la clase hija "Rectangulo".
		figura.dibujar();	
		
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 37 - INTERFACES EN JAVA 
|  VIDEOS: 130, 131, 132, 133.
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Definición de Interfaces (Video 130).

	- Una interface es un nuevo tipo de Java y similar a las clases abstractas ya que sus métodos no tienen ninguna implementación, por lo que todos 
		los métodos que se definen en una inteface van a ser publicos y abstractos.
	- Una interface no es una clase por lo que no hereda de la clase Object ni se pueden crear objetos de tipo Interface.
	- Se puede extender una interface de otras interfaces hijas que heredan los métodos definidos en las interfaces padres.
	- Si se agregan atributos a una interface van a ser de tipo constantes (public final static).
	- Una interface no posee constructores por lo que la declaración de los atributos de la interface tienen que estar siempre inicializados en la 
		declaración del atributo de forma obligatoria.
	- Una interface se utiliza cuando la relación que existe entre clases no es por sus caracteristicas sino por su comportamiento.
	- Uno de los usos en los que se suele utilizar las interfaces es para conectar nuestras clases con BBDD reales ya sea MySQL o Oracle.

2. Creación de una interface (Video 131).

	- Se crea como un nuevo elemento de Java: En el "Project Explorer", haciendo click derecho en el paquete donde va a contener el archivo de clase
	 	tipo Interface -> New -> Inteface.
	- En el nombre de la interface se pone siempre al inicio la letra "I" de interface para saber que es una interface.
	- La declaración de una interface es: 
	
		modificadorAcceso + interface + I + nombreInterface{}
	
		- Ejemplo: Declaración de una interface tipica para el uso con BBDD.
		
			// Declaración de una interface.
			public interface IAccesoDatos 
			{
				
				// Declaración de un atributo de tipo constante.
				public static final int MAX_REGISTRO = 10;
				
				// Declaración de métodos caracteristicos del trabajo con BBDD.
				public abstract void consultar();
				public abstract void insertar();
				public abstract void actualizar();
				public abstract void eliminar();
				
			}
			
3. Uso o implementación de una interface (Video 132).

	- Para implementar o asociar una interface a una clase se utiliza la palabra reservada "implements" en la declaración de la clase.
	- Esta operación produce que en la clase de implementación de la interface se debe de definir todos los métodos abstractos que se han definido
		en la interface.
	- Se puede decir que es como una clase padre/hijos en la que el padre es la interface y los hijos son las clases con la palabra "implements" pero
		no son clases como tal, ya que una interface no es una clase.
	
		public class nombreClase implements nombreInterface {}
		
		public class ImplementacionMySQL implements IAccesoDatos
		{
			
			// Se declaran todos los métodos abstractos que se han declarado en la interface.
	
			@Override
			public void consultar() 
			{
				System.out.println("Consultar desde Oracle.");
			}
		
			@Override
			public void insertar() 
			{
				System.out.println("Insertar desde Oracle.");
			}
		
			@Override
			public void actualizar() 
			{
				System.out.println("Actualizar desde Oracle.");
			}
		
			@Override
			public void eliminar() 
			{
				System.out.println("Eliminar desde Oracle.");
			}
			
		}

4. Prueba de una interface (Video 133).

	- Se debe de declarar una variable de tipo interface.
	- Las interfaces tienen como objetivo la creación de métodos más genericos recibiendo variables tipo Interface y estas variables tipo Interface 
		pueden apuntar a objetos que hayan implementado esta interface.
		
		// Declaración de una variable de tipo Interface, pero como no puede crear objetos por si sóla, pues se crea un objeto de una de las clases 
		// que se han implementado con la interface "IAccesoDatos", en este caso, la clase "ImplementacionMySQL".
		IAccesoDatos datos = new ImplementacionMySQL();
		
		// Llamada al método consultar, pero en este caso, al estar apuntando la variable "datos" a la clase "ImplementaciónMySQL" esta utilizando
		// el método de dicha clase.
		datos.consultar();
		
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 38 - JAVABEANS EN JAVA 
|  VIDEOS: 134, 135.
---------------------------------------------------------------------------------------------------------------------------------------------------|

Manejo de JavaBeans (Video 134).

	JavaBeans es un tipo de clase que debe de cumplir unas ciertas características:
		
		1) Debe tener implementada la clase con una interface llamada Serializable y para ello, en la declaración de la clase, se debe de indicar lo 
			 siguiente:
			
			 public class Persona implements Serializable{}
			
		2) Cada atributo debe de ser un atributo private.
		3) Debe de tener al menos un constructor vacío.
		4) Cada atributo private tiene que tener un método public get() y public set() asociado.
			
		- La interface Serializable nos va a permitir enviar nuestra clase entre diferentes equipos, ya que si tenemos diferentes servidores de Java y 
			necesitamos transferir esta clase de JavaBeans entre diferentes equipos, va a ser importante la implementación de la interface Serializable.
			
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 39 - EXCEPCIONES EN JAVA 
|  VIDEOS: 136, 137, 138, 139, 140, 141.
---------------------------------------------------------------------------------------------------------------------------------------------------|

Manejo de Excepciones (Video 136).

	Existen varios tipos de excepciones en Java: Imagen "01 - Tipos de Excepciones.png".
	
		Exception -> RuntimeException	-> NullPointerException
								 SQLException 
	
	- Actualmente, se recomienda utilizar el tipo de excepción RuntimeException frente al tipo Exception.
	- Existen diferentes formas de tratar el manejo de excepciones en Java según se utilice la clase Exception o la clase RuntimeException.
	
1) Clase Exception: Las clases que heredan de la clase Exception son de tipo "Check Exception", por lo que el compilador nos va a obligar a crear
										un bloque "try catch".
		
	1.1) Creación de una clase propia creada por mi para manejar las excepciones de tipo Exception (Video 138).
	
		- Declaración.
			
			- La nueva clase creada debe de ser hija de la clase Exception por lo que se utiliza la palabra "extends".
			- Se debe de crear un constructor que tenga un argumento de tipo cadena llamada "mensaje" para almacenar el mensaje de error.
			- En el constructor, se debe de llamar al constructor de la clase padre "Exception" con la palabra "super()" y pasandole la variable creada 
				de tipo String llamada "mensaje".
				 
			public class nombreClase extends Exception
			{
				public nombreClase(String mensaje)
				{
					super(mensaje);
				}
			}
			
			- Ejemplo:
			
				public class ClaseException extends Exception
				{
					public ClaseException(String mensaje)
					{
						super(mensaje);
					}
				}
				
	1.2) Creación de una clase donde se utiliza la clase de tipo Exception creada (138, 139).
			
			- Declaración de la clase: Uso de la palabra reservada "throws + nombreClaseException".
			- Cuerpo de la clase: Uso de la palabra reservada "throw new + nombreClaseException(argumentoMensaje)".
			
			- Ejemplo: Se declara una clase que va a tener un método en el cual se va a realizar la división entre dos números.
		
				// En la declaración de este método se debe de indicar que en éste método se puede producir una excepción y eso se indica con la palabra 
				// "throws nombreClaseException".
				public static int division(int numerador, int denominador) throws ClaseException
				{
					
					// Si se va a dividir entre 0, se va a producir un error.
					if (denominador == 0)
					{
						
						// Se crea un objeto de la clase creada de tipo Exception pero para ello se utiliza la palabra reservada "throw new" y se le pasa el 
						// argumento del mensaje. 
						throw new ClaseException("División entre cero.");
					}
					else
					{
						return numerador / denominador;
					}
				}

	1.3) Uso de Excepciones usando el tipo de clase Exception (Video 136, 137, 139, 141).
	
		El bloque "try catch" sirve para enmascarar un error que se produce en una sentencia y poder dar la información del error por consola.
		Se pueden añadir tantos catch como tipos de clases de excepciones tengamos, por lo que se crea un bloque "catch" para cada una de ellas pero
		siempre el bloque "catch" de la clase "Exception" tiene que ir como último bloque "catch".
		
		- Declaración.
		
			try
			{
				Línea o lineas donde se produce el error.
			}
			catch(claseException w_error)
			{
			
				// Si se quiere mostrar sólo el mensaje del error que se ha creado en la clase "Aritmetica", se utiliza el método "getMessage()" de la 
				// la variable "w_error".
				System.out.println("ERROR - Se ha producido el siguiente error (ClaseException): " + w_error.getMessage());
			}			
			catch(Exception w_error)	// Se guarda el error producido en una variable "w_error".
			{
				w_error.printStackTrace(System.out);		// Con el método "printStackTrace(System.out)" de la variable de tipo Exception, se indica que se 
																								// imprima el error guardado en la variable "w_error" por consola.
			}
			// Este bloque se ejecuta siempre se haya producido el error o no.
			// Se suele utilizar para cerrar una conexión a la BBDD o cerrar un archivo que ha sido abierto.
			finally
			{
				// Cerrar la conexión a BBDD o el archivo abierto.
			}
		
		- Uso.
		
			- Ejemplo: Se produce un error en una división de un número por 0 y se debe de controlar utilizando el bloque "try catch".
		
				public class PruebaException 
				{
					public static void main(String[] args) 
					{
				
						// Declaración de variables.
						int dividendo = 10;
						int divisor = 0;
						int resultado = 0;
						
						// Se crea un bloque donde se produce el error para enmascarar y que no salte como error sino que informe del error producido y lo 
						// muestre por la consola.
						try
						{
							resultado = AritmeticaException.division(dividendo, divisor);		// Línea donde se va a producir el error por dividir entre 0.
						}
						// Se pueden añadir tantos catch como tipos de clases de excepciones tengamos, por lo que se crea un bloque "catch" para cada una de 
						// ellas.
						// Excepción de la clase creada "ClaseException".
						catch(ClaseException w_error)	// Se guarda el error en la variable "w_error".
						{
							
							// Si se quiere mostrar sólo el mensaje del error que se ha creado en la clase "Aritmetica", se utiliza el método "getMessage()" de
							// la variable "w_error".
							System.out.println("ERROR - Se ha producido el siguiente error (ClaseException): " + w_error.getMessage());
						
						}
						// Excepción de la clase "Exception", ésta clase siempre debe de ir como último "catch".
						catch(Exception w_error)	// Se guarda el error en la variable "w_error".
						{
							
							// Si se quiere mostrar sólo el mensaje del error que se ha creado en la clase "Aritmetica", se utiliza el método "getMessage()" de
							// la variable "w_error".
							System.out.print("ERROR - Se ha producido el siguiente error (Exception): " + w_error.getMessage());
							
							// Si se quiere mostrar toda la pila de errores y que se imprima el error guardado en la variable "w_error" por consola se utiliza
							//  el método "printStackTrace(System.out)" de la variable "w_error".
							w_error.printStackTrace(System.out);		
							
						}
						// Este bloque se ejecuta siempre se haya producido el error o no.
						// Se suele utilizar para cerrar una conexión a la BBDD o cerrar un archivo que ha sido abierto.
						finally
						{
							System.out.println("Se revisó la división entre 0.");
						}
						
						// Si la división no es por 0, pues se muestra el resultado de la división.
						if (divisor != 0)
						{
							System.out.println("Resultado de la división: " + resultado);
						}
					}
				}
								
2) Clase RuntimeException: Las clases que heredan de la clase RuntimeException son de tipo "Uncheck Exception", por lo que el compilador no nos
													 obliga a crear un bloque "try catch".
													 
	2.1) Creación de una clase propia creada por mi para manejar las excepciones de tipo Exception (Video 140).
	
		- Declaración.
			
			- La nueva clase creada debe de ser hija de la clase ExceptionRuntime por lo que se utiliza la palabra "extends".
			- Se debe de crear un constructor que tenga un argumento de tipo cadena llamada "mensaje" para almacenar el mensaje de error.
			- En el constructor, se debe de llamar al constructor de la clase padre "ExceptionRuntime" con la palabra "super()" y pasandole la variable
			  creada de tipo String llamada "mensaje".
				 
				public class nombreClase extends RuntimeException
				{
					public nombreClase(String mensaje)
					{
						super(mensaje);
					}
				}
			
			- Ejemplo:
			
				public class ClaseRuntimeException extends RuntimeException
				{
					public ClaseRuntimeException(String mensaje)
					{
						super(mensaje);
					}
				}

	2.2) Creación de una clase donde se utiliza la clase de tipo RuntimeException creada (140).
			
			- Ejemplo: Se declara una clase que va a tener un método en el cual se va a realizar la división entre dos números.
		
				public static int division(int numerador, int denominador)
				{
					
					// Si se va a dividir entre 0, se va a producir un error.
					if (denominador == 0)
					{
						
						// Se crea un objeto de la clase creada de tipo Exception pero para ello se utiliza la palabra reservada "throw new" y se le pasa el 
						// argumento del mensaje. 
						throw new ClaseRuntimeException("División entre cero.");
					}
					else
					{
						return numerador / denominador;
					}
				}
				
	2.3) Uso de Excepciones usando el tipo de clase RuntimeException (Video 140).
	
		- En este caso, no tenemos que utilizar el bloque "try catch".
		
		- Ejemplo: Se produce un error en una división de un número por 0 y se debe de controlar utilizando la clase RuntimeException.
	
			public static void main(String[] args) 
			{
		
				// Declaración de variables.
				int dividendo = 10;
				int divisor = 0;
				int resultado = 0;
				
				// Línea donde se va a producir el error por dividir entre 0.
				resultado = AritmeticaRuntimeException.division(dividendo, divisor);		
				
				// Si la división no es por 0, pues se muestra el resultado de la división.
				if (divisor != 0)
				{
					System.out.println("Resultado de la división: " + resultado);
				}
			}

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 40 - API COLLECTION (COLECCIONES) EN JAVA 
|  VIDEOS: 142, 143, 144, 145.
---------------------------------------------------------------------------------------------------------------------------------------------------|

API Collection - Colecciones (Video 142).

	- Una colección es un conjunto de datos, que pueden o no tener un ordenamiento particular. 
	- Las colecciones es muy similar a los arreglos, sin embargo, los arreglos es una estructura más simple que el manejo de colecciones.
	- Las colecciones se conocen también como Estructuras de Datos, ya que permiten almacenar información de manera estructurada y de maneras más 
	  variadas que en los arreglos.
	- Los datos que puede tener una colección pueden necesitar un cierto orden, además de posiblemente necesitemos agregar más registros conforme 
	  vamos necesitando, y como sabemos en un arreglo debemos declarar el número de elemento que contendrá el arreglo. 
	- Una colección es más flexible y permite ir agregando elementos conforme vayamos necesitando de manera más dinámica, además de que puede tener
	  métodos de ordenamiento, búsqueda, evitar valores duplicados, entre muchas otras características, todo depende del tipo de colección que 
	  utilicemos.
	- Existe un API llamada "API Collection" ya definida en Java, en la cual se tiene un conjunto de clases que permiten resolver problemas 
		específicos de las colecciones, se encuentra en el paquete de Java "java.util" y su esquema de clases y elementos se puede ver en la imágen 
		"01 - Esquema API Collection.png".
		
	El API de Colecciones, de manera simple se divide los siguientes elementos:
		
		- Interface Collection: Es la interface principal de la API y todas las clases descienden de esta interface.
		- Interface List. 
		
			+ Clase ArrayList.
			+ Clase Vector.
			
		- Interface Set.
			
			+ Clase Hashset. 
			
		- Interface Map. 
		
			+ Clase HashMap.
			
1) Listas (List) (Video 143).
	
	- Una lista es una interface que se usa para tratar colección de tipo ordenada que sí permiten elementos duplicados.
	- Una lista es muy parecida a un arreglo o array pero en la lista no hay que indicar el número máximo de elementos que va a contener el array
		sino que una lista puede ir añadiendo elementos de forma dinámica según se necesite.
	- Para poder usar una lista, al ser una interface, no se puede crear un objeto directamente del tipo interface por lo que se debe de utilizar
		una de las clases hijas relacionadas, por ejemplo, la clase "ArrayList()".
	
	- En una lista, el orden de los elementos se mantiene según se han ido añadiendo a la lista.
	
	1.1. Declaración de una lista.
		
		import java.util.ArrayList;
		import java.util.List;
		
		List nombreObjetoList = new ArrayList();
		
		List listaDiasSemana = new ArrayList();
		
	1.2. Añadir un objeto nuevo a la lista mediante el método "add()".
		
		Para añadir un nuevo elemento a la lista se utiliza el método "add()" en el cual se indica por argumento el objeto que se va a añadir, sin
		importar el tipo de objeto que sea.
		
		nombreObjetoList.add(objetoAñadir);
		
		// Añadimos en la lista de forma dinámica todos los días de la semana.
		
		listaDiasSemana.add("Lunes");
		listaDiasSemana.add("Martes");
		listaDiasSemana.add("Miércoles");
		listaDiasSemana.add("Jueves");
		listaDiasSemana.add("Viernes");
		listaDiasSemana.add("Sábado");
		listaDiasSemana.add("Domingo");
		listaDiasSemana.add("Domingo");		// Permite duplicar elementos.
		
	1.3. Mostrar los elementos de la lista mediante el bucle "foreach".
	
		Se recorre con un bucle "foreach" todos los elementos de la lista, indicando que la variable es de tipo "Object" y que se llama 
		"elementosLista" y también indicando el nombre de la lista, en este caso, "listaDiasSemana".
		
		for (Object nombreVariable : nombreLista) 
		{
			codigo;
		}
		
		// Se recorre la lista de días de la semana.
		
		for (Object elementoLista : listaDiasSemana) 
		{
			System.out.println("Elemento: " + elementoLista);
		}

2. Interface Set (Video 144).

	- Un set es una interface que se usa para tratar colecciones de tipo no ordenada, por lo que los elementos no se muestran en consola en el 
		órden que se insertaron sino en cualquier tipo de órden.
	- Un set no permite elementos duplicados y por ello, los elementos duplicados no se insertarán en la colección.
	- Una set es muy parecida a un arreglo o array pero en el set no hay que indicar el número máximo de elementos que va a contener el array
		sino que una lista puede ir añadiendo elementos de forma dinámica según se necesite.
	- Para poder usar una interface set, al ser una interface, no se puede crear un objeto directamente del tipo interface por lo que se debe de 
		utilizar una de las clases hijas relacionadas, por ejemplo, la clase "HashSet()".

	2.1. Declaración de un Set.
		
		import java.util.HashSet;
		import java.util.Set;
		
		Set nombreObjetoSet = new HashSet();
		
		Set setDiasSemana = new HashSet();

	2.2. Añadir un objeto nuevo al Set mediante el método "add()".
		
		Para añadir un nuevo elemento al Set se utiliza el método "add()" en el cual se indica por argumento el objeto que se va a añadir, sin
		importar el tipo de objeto que sea.
		
		nombreObjetoSet.add(objetoAñadir);
		
		// Añadimos en el Set de forma dinámica todos los días de la semana.
		
		setDiasSemana.add("Lunes");
		setDiasSemana.add("Martes");
		setDiasSemana.add("Miércoles");
		setDiasSemana.add("Jueves");
		setDiasSemana.add("Viernes");
		setDiasSemana.add("Sábado");
		setDiasSemana.add("Domingo");
		setDiasSemana.add("Domingo");		// No permite duplicar elementos.	

	2.3. Mostrar los elementos del Set mediante el bucle "foreach".
	
		Se recorre con un bucle "foreach" todos los elementos del Set, indicando que la variable es de tipo "Object" y que se llama 
		"elementosLista" y también indicando el nombre del Set, en este caso, "setDiasSemana".
		
		for (Object nombreVariable : nombreSet) 
		{
			codigo;
		}
		
		// Se recorre el Set de días de la semana.
		
		for (Object elementoLista : setDiasSemana) 
		{
			System.out.println("Elemento: " + elementoLista);
		}

	2.4. Método para imprimir todos los elementos ya sea de una lista o de un set (Video 144).

		- El tipo del argumento a pasar tiene que ser el tipo más generico, en este caso, la interface Collection, ya que es la interface 
		 	padre para los tipos List y Set.
		 	
			public static void imprimirLista(Collection tipoLista)
			{
				
				// Se recorre con un bucle "foreach" todos los elementos de la lista, indicando que la variable es de tipo "Object" y que se llama 
				// "elementosLista" y también indicando el nombre de la lista, en este caso, "tipoLista".
				
				for (Object elementoLista : tipoLista) 
				{
					System.out.println("Elemento: " + elementoLista);
				}
			}
	
3. Interface Map (Video 145).

	- Un Mapa es una interface que se utilza para trabajar con colecciones que relaciona una llave (key) con un valor, formando una especia de
		tabla de datos.
	- Para poder usar una interface Map, al ser una interface, no se puede crear un objeto directamente del tipo interface por lo que se debe de 
		utilizar una de las clases hijas relacionadas, por ejemplo, la clase "HashMap()".
	
	3.1. Declaración de un Map.
		
		import java.util.HashMap;
		import java.util.Map;
		
		Map nombreObjetoMap = new HashMap();
		
		Map mapaNombres = new HashMap();
	
	3.2. Añadir un objeto nuevo al Mapa mediante el método "put()".
		
		Para añadir un nuevo elemento al Mapa se utiliza el método "put()" en el cual se indica como primer argumento el objeto que se va a añadir,
		sin importar el tipo de objeto que sea, que va a corresponder al "key" y luego como segundo argumento, se le pasa otro objeto que va a ser
		el "valor" asociado al "key".
		
		nombreObjetoMap.put(objetoAñadirKey, objetoAñadirValor);
		
		// Añadimos en el Mapa de forma dinámica todos varios nombres.
		
		mapaNombres.put("Nombre1", "Alfonso");
		mapaNombres.put("Nombre2", "Isabel");
		mapaNombres.put("Nombre3", "Álex");

	3.3. Obtener un valor de un Mapa utilizando el "key" asociado.
	
		Para obtener el valor de un elemento determinado del Mapa, se utiliza el método "get()" y se debe de indicar la "key" que queremos obtener.
		
		Ejemplo: System.out.println("Elemento Map: " + mapaNombres.get("Nombre1"));
	
	3.4. Mostrar los elementos del Mapa, mediante el bucle "foreach".
		
		Los mapas para recorrer sus valores, primero se debe de tener claro que es lo que se quiere obtener:
		
			- Obtener los keys: Se utiliza el método "keySet()".
			- Obtener los valores: Se utiliza el método "values()".
			
		Estos dos métodos devuelven una lista Set por lo que se recorre con un bucle "foreach" todos los elementos del Set del tipo Mapa, indicando
		que la variable es de tipo "Object" y que se llama "elementosLista" y también indicando el Set que devuelve el método "keySet" o "values".
		
		for (Object nombreVariable : nombreSet) 
		{
			codigo;
		}
		
		// Obtiene todos los elementos keys del Mapa.
		
		for (Object elementoLista : mapaNombres.keySet()) 
		{
			System.out.println("Key: " + elementoLista);
		}
		
		// Obtiene todos los valores asociados a los elementos keys del Mapa.
		
		for (Object elementoLista : mapaNombres.values()) 
		{
			System.out.println("Valor: " + elementoLista);
		}

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 41 - TIPOS GENERICOS O GENERICS EN JAVA 
|  VIDEOS: 146, 147, 148, 149.
---------------------------------------------------------------------------------------------------------------------------------------------------|

Tipos genericos o Generics (Video 146).

	- Un tipo generico es como un tipo comodín en el cual cuando definimos nuestra clase no vamos a indicar el tipo de dato que va almacenar o 
		utilizar nuestra clase, sino que hasta el momento en que creamos un objeto de esta clase, es cuando vamos a especificar el tipo de dato que 
		vamos a utilizar.
	
	- Existen diferentes nomenclaturas para indicar un tipo genérico: (Ver imágen "01 - Tipos Genericos.png").
	
		- Tipo generico E: Element (Uso en colecciones).
		- Tipo generico K: Key (Llave utilizando en Mapas).
		- Tipo generico V: Value (Valor utilizado en Mapas).
		- Tipo generico N: Number (Uso para números).
		- Tipo generico T: Type (Representa una clase).
		- Tipo genericos S, U, etc: Usado para representar otros tipos.
		
1. Creación de una clase que va a contener un atributo de tipo genérico, en este caso, del tipo genérico "T": Type (Representa una clase).

	- En la declaración de la clase, a continuación del nombre se debe de indicar entre "<>" el tipo genérico que se va a utilizar.
	
		public class ClaseGenerica <T>
		{
		}
		
	- Se puede declarar un atributo de clase con el tipo "T": private T objetoTipoGenerico;
	- Se puede declarar un constructor con un argumento de tipo "T":
	
		public ClaseGenerica(T objetoTipoGenerico)
		{
			this.objetoTipoGenerico = objetoTipoGenerico;
		}
		
	- Se puede crear un método para que muestre por consola, que tipo va a ser finalmente el que tenga el atributo de clase "objetoTipoGenerico".
	
		public void obtenerTipo()
		{
			System.out.println("El tipo T es de tipo: " + this.objetoTipoGenerico.getClass().getSimpleName());
		}
		
2. Declaración de un objeto que tiene un tipo genérico (Video 147).
	
	- En la declaración del objeto se debe de indicar el tipo que va a tener el objeto siendo posible los tipos (Autoboxing Sección 29 - Video 113):
	
		- Integer.
		- String.
		- Long.
		- Float.
		- Double.
		- Boolean.
		- Byte.
		- Character.
		- Short.
		
	- Declaración del objeto indicando que el tipo.
	
		nombreClaseGenerica<tipo> nombreObjeto = new nombreClaseGenerica(objeto)
	
	- Se realiza Autoboxing: Se esta convirtiendo un tipo primitivo int al ser un número entero (15) a un tipo Integer, por lo que el tipo del
		atributo de la clase, va a tener el tipo integer.
		
		ClaseGenerica<Integer> objetoInt = new ClaseGenerica(15); 	
		
	- Se obtiene el tipo que tiene el objeto llamando al método "obtenerTipo()".
	
		objetoInt.obtenerTipo();
		
3. Uso de tipos genericos con la API de Colecciones (Collections).

3.1. Listas genericas (List).
	
	En una lista (List), para restringir el tipo de objeto que va a contener la lista, se debe de indicar el tipo que va a contener y para ello se 
	utiliza el operador del tipo genérico "<>", en el cual se indica el tipo que va a tener todos los elementos de la lista, ya que si no se indica
	el tipo, en la lista, al recibir un objeto, da igual el tipo que sea y de esta forma se restringe a que sea del tipo indicado.
	
	3.1.1 Declaración de un objeto de tipo Lista indicando el tipo.
		
		import java.util.ArrayList;
		import java.util.List;
		
		List <tipo> nombreLista = new ArrayList <tipo>();
		
		List<String> listaDiasSemana = new ArrayList<String>();
		
	3.1.2. Obtener un determinado valor de la lista.
		
		Para obtener un valor determinado de una lista List se debe de utilizar el método "get()" pasando por argumento el indice del elemento a 
		recuperar.
		
			tipoDatoElemento elemento = nombreLista.get(indiceElemento);
				
			String elemento = listaDiasSemana.get(0);	-> Elemento "Lunes".
		
	3.1.3. Método para imprimir todos los elementos ya sea de una lista o de un set (Video 144 y Video 148).

		- El tipo del argumento a pasar tiene que ser el tipo más generico, en este caso, la interface Collection, ya que es la interface 
		 	padre para los tipos List y Set.
		- Para restringir el tipo de dato que va a recibir la variable "tipoLista" se indica el tipo que va a contener la colección y para ello se 
			utiliza las "<>" y se indica el tipo de los datos que va a contener la lista.
		
			public static void imprimirLista(Collection <tipoDatoLista> tipoLista)
			{
				
				// Se recorre con un bucle "foreach" todos los elementos de la lista, indicando que la variable es de tipo "String" debido a que ya sabemos
				// el tipo del objeto con el que se va a trabajar, en este caso, la variable "elementosLista" y también indicando el nombre de la lista, 
				// en este caso, "tipoLista".
				
				for (tipoDatoLista elementoLista : tipoLista) 
				{
					System.out.println("Elemento: " + elementoLista);
				}
			}
		
			public static void imprimirLista(Collection <String> tipoLista)
			{
				
				// Se recorre con un bucle "foreach" todos los elementos de la lista, indicando que la variable es de tipo "String" debido a que ya sabemos
				// el tipo del objeto con el que se va a trabajar, en este caso, la variable "elementosLista" y también indicando el nombre de la lista, 
				// en este caso, "tipoLista".
				
				for (String elementoLista : tipoLista) 
				{
					System.out.println("Elemento: " + elementoLista);
				}
			}
		
3.2. Set genericos (Video 149).

	En un Set, para restringir el tipo de objeto que va a contener el Set, se debe de indicar el tipo que va a contener y para ello se 
	utiliza el operador del tipo genérico "<>", en el cual se indica el tipo que va a tener todos los elementos del Set, ya que si no se indica
	el tipo, en el Set, al recibir un objeto, da igual el tipo que sea y de esta forma se restringe a que sea del tipo indicado.
	
	3.2.1 Declaración de un objeto de tipo Set indicando el tipo.
		
		import java.util.HashSet;
		import java.util.Set;
		
		Set <tipo> nombreSet = new HashSet <tipo>();
		
		Set <String> setDiasSemana = new HashSet <String>();
		
3.3. Mapa genérico (Video 149).

	En un Mapa, para restringir el tipo de objeto que va a contener el Mapa, se debe de indicar el tipo que va a contener y para ello se 
	utiliza el operador del tipo genérico "<>", en el cual se indica el tipo que va a tener todos los elementos del Mapa, ya que si no se indica
	el tipo, en el Mapa, al recibir un objeto, da igual el tipo que sea y de esta forma se restringe a que sea del tipo indicado.
		
	3.3.1 Declaración de un objeto de tipo Mapa indicando el tipo.
		
		import java.util.HashMap;
		import java.util.Map;
		
		Map <tipoLlave, tipoValor> nombreObjetoMap = new HashMap <tipoLlave, tipoValor> ();
		
		Map <String, String> mapaNombres = new HashMap <String, String> ();
		
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 02 - SECCIÓN 42 - MANEJO DE ARCHIVOS EN JAVA 
|  VIDEOS: 150, 151, 152, 153, 154.
---------------------------------------------------------------------------------------------------------------------------------------------------|

Uso de Archivos (Video 150).

	- Cuando se trabaja con archivos hay que implementar una serie de métodos de tipo estáticos que son comunes ya que son las opciones que se pueden
		realizar con el uso de un archivo y son:
	
		1) Creación del archivo 								-> Método ManejarArchivos.crearArchivo()
		2) Guardar información en el archivo.		-> Método ManejarArchivos.escribirArchivo()
		3) Anexar información en el archivo.		-> Método ManejarArchivos.anexarContenidoArchivo()
		4) Leer la información del archivo.
		5) Otras operaciones.

1. Método de creación del archivo (Video 150).

	- Se detalla la creación del método "crearArchivo()" dentro de la clase "ManejarArchivos" para crear fiicamente un archivo en nuestro HDD.

		import java.io.File;
		import java.io.FileNotFoundException;
		import java.io.PrintWriter;
	
		// 1. Declaración del método para crear el archivo físico en el HDD.
		public static void crearArchivo(String nombreArchivo)
		{
			
			// 1.1. Creación de un objeto de tipo File en memoria donde se le pasa el argumento "nombreArchivo".
			File archivo = new File(nombreArchivo);
			
			// 1.2. Debido a que la clase "PrintWriter" puede dar error, hay que incluirlo dentro de un bloque de excepciones "try catch" 
			// para enmascarar el error de que si no puede crear el archivo. Esta excepción se llama "FileNotFoundException".
			try 
			{
		
				// 1.3. Creación de un objeto de la clase "PrintWriter" que va a abrir el archivo fisicamente en el HDD.
				PrintWriter salida = new PrintWriter(archivo);
				
				// 1.4. Creación del archivo fisicamente en el HDD en el momento del cierre del archivo.
				salida.close();
				
				System.out.println("Se ha creado el archivo: " + nombreArchivo + " correctamente.");
				
			} 
			catch (FileNotFoundException w_error) 
			{
				// Se imprime el error por consola.
				w_error.printStackTrace(System.out);	
			}
		}
	
	- Se detalla la clase "PruebaManejoArchivos" para que se produzca la creación del archivo indicado (Video 151).
	
		public static void main(String[] args) 
		{
		
		// 1. Creación del archivo de forma fisica.
		
			// 1.1. Declaración de unas variables donde se indica la ruta y el nombre del archivo a crear.
			//	  	Para indicar la barra invertida de la ruta, se debe de indicar dos barras.
			
				String ruta = "C:\\CFGS\\Curso01_Udemy_Universidad_Java\\Bloque02_Programacion\\Seccion42_ManejoArchivos\\Archivos\\";
				String nombre = "prueba.txt";
				
			// 1..2. Se declara una variable que contenga la ruta y el nombre del archivo a crear si se quiere que se cree en un directorio determinado.
				
				String nombreArchivo = ruta + nombre;
			
			// 1.3. Se llama al método "ManejoArchivos.crearArchivo()" para que se realice la creación del archivo.
				
				ManejoArchivos.crearArchivo(nombreArchivo);
			
			// Si se quiere sólo indicar el nombre del archivo y no la ruta, pues el archivo se crea en la carpeta principal del proyecto.
			// En este caso, la ruta principal del proyecto es: "C:\CFGS\Curso01_Udemy_Universidad_Java"
	
			// Se llama de nuevo al método "ManejoArchivos.crearArchivo()" para que se realice la creación del archivo sin indicar la ruta.
			
			 	ManejoArchivos.crearArchivo(nombre);
			 
		}
		
2. Método de añadir información por primera vez en el archivo indicado (Video 152).

	- Se detalla la creación del método "escribirArchivo()" dentro de la clase "ManejarArchivos" para escribir la información que le pasamos
		con el argumento "contenidoArchivo".

		import java.io.File;
		import java.io.FileNotFoundException;
		import java.io.PrintWriter;

		// 2. Declaración del método para añadir información en el archivo creado (Video 152).	
		public static void escribirArchivo(String nombreArchivo, String contenidoArchivo)
		{
			
			// 2.1. Creación de un objeto de tipo File en memoria donde se le pasa el argumento "nombreArchivo".
			File archivo = new File(nombreArchivo);
			
			// 2.2. Debido a que la clase "PrintWriter" puede dar error, hay que incluirlo dentro de un bloque de excepciones "try catch" 
			// para enmascarar el error de que si no puede encontrar el archivo. Esta excepción se llama "FileNotFoundException".
			try 
			{
				
				// 2.3. Creación de un objeto de la clase "PrintWriter" que va a abrir el archivo fisicamente en el HDD.
				PrintWriter salida = new PrintWriter(archivo);
				
				// 2.4. Se utiliza el método "println" para añadir la información al archivo. Éste método puede pasarse por argumento cualquier tipo
				// de objeto.
				salida.println(contenidoArchivo);
				
				// 2.5. Se guarda el archivo fisicamente en el HDD en el momento del cierre del archivo.
				salida.close();
				
				System.out.println("Se ha escrito en el archivo: " + nombreArchivo + " correctamente.");
				
			} 
			catch (FileNotFoundException w_error) 
			{
				// Se imprime el error por consola.
				w_error.printStackTrace(System.out);	
			}
		}

	- Se detalla la clase "PruebaManejoArchivos" para que se produzca la escritura de la información indicada en el archivo creado en el punto 1.
	
		public static void main(String[] args) 
		{
		
			// 2. Escribir contenido en el archivo anteriormente creado (Video 152).
		
			// 2.1. Se declara una variable con la información que va a contener el archivo.
			String contenidoArchivo = "Hola desde Java.";
		
			// 2.1. Se llama al método "escribirArchivo()" para incluir la información pasada por argumento en el archivo indicado.
			ManejoArchivos.escribirArchivo(nombreArchivo, contenidoArchivo);		
		}
		
3. Método para añadir información a la ya existente en el archivo indicado (Video 153).

	- Se detalla la creación del método "anexarContenidoArchivo()" dentro de la clase "ManejarArchivos" para anexar la información que le pasamos
		con el argumento "contenidoArchivo".

		import java.io.File;
		import java.io.FileNotFoundException;
		import java.io.PrintWriter;
		import java.io.FileWriter;
		import java.io.IOException;
		
		// 3. Declaración del método para añadir información a la ya existente en el archivo creado (Video 153).
		public static void anexarContenidoArchivo(String nombreArchivo, String contenidoArchivo)
		{
			
			// 3.1. Creación de un objeto de tipo File en memoria donde se le pasa el argumento "nombreArchivo".
			File archivo = new File(nombreArchivo);
			
			// 3.2. Debido a que la clase "PrintWriter" puede dar error, hay que incluirlo dentro de un bloque de excepciones "try catch" 
			// para enmascarar el error de que si no puede encontrar el archivo. Esta excepción se llama "FileNotFoundException".
			try 
			{
				
				// 3.3. Creación de un objeto de la clase "FileWriter" que va a permitir anexar información a la que ya exista en el archivo.
				FileWriter anexar = new FileWriter(archivo, true);	// Si se pasa por argumento "true" indica que se anexa información.
																														// Si se pasa por argumento "false" indica que no se anexa información. 
				
				// 3.4. Creación de un objeto de la clase "PrintWriter" que va a abrir el archivo fisicamente en el HDD y se le pasa el objeto FileWriter.
				PrintWriter salida = new PrintWriter(anexar);
				
				// 3.5. Se utiliza el método "println" para añadir la información al archivo. Éste método puede pasarse por argumento cualquier tipo
				// de objeto.
				salida.println(contenidoArchivo);
				
				// 3.6. Se guarda el archivo fisicamente en el HDD en el momento del cierre del archivo.
				salida.close();
				
				System.out.println("Se ha anexado la nueva información en el archivo: " + nombreArchivo + " correctamente.");
				
			} 
			// Error: No se encuentra el archivo (PrintWriter).
			catch (FileNotFoundException w_error) 
			{
				// Se imprime el error por consola.
				w_error.printStackTrace(System.out);	
			} 
			catch (IOException w_error) 
			{
				// Se imprime el error por consola.
				w_error.printStackTrace(System.out);	
			}
		}

	- Se detalla la clase "PruebaManejoArchivos" para que se produzca el añadido de la información indicada en el archivo creado en el punto 1.
	
		public static void main(String[] args) 
		{
		
			// 3. Anexar contenido al ya existente en el archivo anteriormente creado (Video 153).
		
			// 3.1. Se declara una variable con la información que va a añadir al contenido del archivo.
			String contenidoArchivo2 = "Adios desde Java.";
		
			// 3.2. Se llama al método "anexarContenidoArchivo()" para anexar la información pasada por argumento en el archivo indicado.
			ManejoArchivos.anexarContenidoArchivo(nombreArchivo, contenidoArchivo2);
		
		}

4. Método para leer la información que existe en el archivo indicado (Video 154).

	- Se detalla la creación del método "obtenerContenidoArchivo()" dentro de la clase "ManejarArchivos" para leer la información del archivo creado 
		en el punto 1.

		import java.io.BufferedReader;
		import java.io.File;
		import java.io.FileNotFoundException;
		import java.io.FileReader;
		import java.io.FileWriter;
		import java.io.IOException;
		import java.io.PrintWriter;

		// 4. Declaración del método para leer la información que contiene el archivo creado (Video 154).
		public static void obtenerContenidoArchivo(String nombreArchivo)
		{
			
			// 4.1. Creación de un objeto de tipo File en memoria donde se le pasa el argumento "nombreArchivo".
			File archivo = new File(nombreArchivo);
	
			// 4.2. Debido a que la clase "PrintWriter" puede dar error, hay que incluirlo dentro de un bloque de excepciones "try catch" 
			// para enmascarar el error de que si no puede encontrar el archivo. Esta excepción se llama "FileNotFoundException".
			try 
			{
				// 4.3. Creación de un objeto de tipo FileReader para poder leer el contenido del archivo "nombreArchivo".
				FileReader lector = new FileReader(archivo);
				
				// 4.4. Creación de un objeto de tipo BufferedReader para poder almacenar en el buffer toda la información que existe en el archivo.
				// 			Se le pasa como argumento el objeto de FileReader creado anteriomente.
				BufferedReader entrada = new BufferedReader(lector);
				
				// 4.5. Se realiza la lectura de la primera linea completa de nuestro archivo y se guarda en la variable "lectura".
				String lectura = entrada.readLine();
				
				// 4.6. Se realiza la lectura del documento completo hasta que no encuentre un null con un bucle While (no hay mas información que leer).
				
				// Se declara una varible contador de las líneas que tiene el archivo de modo informativo.
				int linea = 0;
				
				while (lectura != null)
				{
					// Se incrementa el contador de líneas.
					++linea;
					
					// Se imprime la información de la línea completa leida.
					System.out.println("Línea (" + linea + "): " + lectura);
					
					// Se lee la siguiente línea del archivo.
					lectura = entrada.readLine();
				}
				
				// 4.6. Se cierra el archivo.
				entrada.close();
	
				System.out.println("Se ha leido toda la información del archivo: " + nombreArchivo + " correctamente.");
				
			} 
			// Error: No se encuentra el archivo (PrintWriter).
			catch (FileNotFoundException w_error) 
			{
				// Se imprime el error por consola.
				w_error.printStackTrace(System.out);	
			} 
			catch (IOException w_error) 
			{
				// Se imprime el error por consola.
				w_error.printStackTrace(System.out);	
			}
		}
	
	- Se detalla la clase "PruebaManejoArchivos" para que se produzca la lectura de toda la información indicada en el archivo creado en el punto 1.
	
		public static void main(String[] args) 
		{
			
			// 4.1. Se llama al método "obtenerContenidoArchivo()" para leer la información del archivo indicado.
			ManejoArchivos.obtenerContenidoArchivo(nombreArchivo);
		
		}
		
5. Método para buscar una cadena en un archivo de texto.
	
	import java.io.File;
	
	public String buscar(String nombreArchivo, String buscar) throws LecturaDatosEx, AccesoDatosEx 
	{
		
		// Declaración de variables.
		
		int numlinea = 1;
		boolean existePelicula = false;
		String mensaje = null;
		
		// Si el archivo indicando existe en el directorio.
		if (existe(nombreArchivo) == true)
		{
		
			// Debido a que la clase "Scanner" puede dar error, hay que incluirlo dentro de un bloque de excepciones "try catch" 
			// para enmascarar el error de que si no puede encontrar el archivo. Esta excepción se llama "FileNotFoundException".
			try 
			{
				
				// Creación de un objeto de tipo File en memoria donde se le pasa el argumento "nombreArchivo".
				File archivo = new File(nombreArchivo);
				
				// Creación de un objeto de tipo FileReader para poder leer el contenido del archivo "peliculas.txt".
				FileReader lector = new FileReader(archivo);
				
				// Creación de un objeto de tipo BufferedReader para poder almacenar en el buffer toda la información que existe en el archivo.
				BufferedReader bufferDatos = new BufferedReader(lector);
				
				// Se realiza la lectura de la primera linea completa de nuestro archivo y se guarda en la variable "datosArchivo".
				String datosArchivo = bufferDatos.readLine();
				
				// Mientras existan datos de texto en el archivo.
				while(datosArchivo != null)
				{
					
					// Si se pasa por el argumento "buscar" un nombre de película y existe una línea igual al nombre de pelicula a buscar es que ha encontrado la película en el archivo.
					// Se utiliza el método "equalsIgnoreCase" para comparar las dos cadenas y que no afecte si estan en mayúsculas o minúsculas.
					if(buscar != null && buscar.equalsIgnoreCase(datosArchivo) == true)
					{
						// Si se ha encontrado, cambia la variable "existePelicula" a true y se termina el bucle.
						existePelicula = true;							
						break;
					}
					
					// Si no se ha encontrado todavia, pues se lee la siguiente línea del archvo y se incrementa el contador de líneas.
					datosArchivo = bufferDatos.readLine();
					numlinea++;
				}
				
				// Si se ha encontrado la película, se indica por mensaje.
				if (existePelicula == true)
				{
					mensaje = "\nINFORMACIÓN: La película \"" + buscar + "\" aparece en la línea " + numlinea + " del catálogo de películas.";												
				}
				// Si no se ha encontrado la película, se indica por mensaje.
				else
				{
					mensaje = "\nINFORMACIÓN: La película \"" + buscar + "\" no existe en el catálogo de películas.";
				}
			}

			// ERROR: Error general.
			catch (Exception w_error) 
			{
				// Imprime el error por consola.
				w_error.printStackTrace();
				throw new LecturaDatosEx("ERROR GENERAL - Método Buscar: " + w_error.getMessage());
			}
		}
		// Si el archivo no existe.
		else
		{
			// Imprime el error controlado por consola.
			throw new LecturaDatosEx("ERROR - Método Buscar: El sistema no puede encontrar la ruta/archivo especificada: " + nombreArchivo);
		}
	
		// Se retorna el mensaje indicando si se ha encontrado la película o no en el archivo.
		return mensaje;
	}
	
6. Método para eliminar un archivo.

	import java.io.File;

	public void borrar(String nombreArchivo) throws AccesoDatosEx
	{
		
		// Si el archivo indicando existe en el directorio.
		if (existe(nombreArchivo) == true)
		{
			// Creación de un objeto de tipo File en memoria donde se le pasa el argumento "nombreArchivo".
			File archivo = new File(nombreArchivo);
			
			// Se crea un bloque try catch donde se produce el error para enmascarar y que no salte como error sino que informe del error producido y lo 
			// muestre por la consola.
			try
			{	
				
				// Se borra el archivo y si devuelve true es que se ha borrado correctamente.
				if(archivo.delete() == true)
				{
					System.out.println("\nINFORMACIÓN: El archivo " + nombreArchivo + " se ha borrado correctamente.");
				}
				// Si no se ha borrado correctamente el archivo.
				else
				{
					throw new AccesoDatosEx("\nERROR - Método Borrar: El archivo " + nombreArchivo + " no se ha borrado correctamente.");
				}
			}
			// ERROR: Error general.
			catch (Exception w_error) 
			{
				// Imprime el error por consola.
				w_error.printStackTrace(System.out);
			}
		}
		// Si no existe el archivo a borrar.
		else
		{
			// Imprime el error controlado por consola.
			throw new AccesoDatosEx("\nERROR - Método Borrar: El archivo " + nombreArchivo + " ya no existe en el sistema.");
		}
	}

7. Método para saber si existe un archivo.

	import java.io.File;
	
	// Declaración del método que comprueba si existe el archivo.
	public boolean existe(String nombreArchivo)
	{
		
		// Creación de un objeto de tipo File en memoria donde se l pasa el argumento "nombreArchivo".		
		File archivo = new File(nombreArchivo);
		
		// Si el archivo existe, devuelve true, sino pues devuelve false.
		if (archivo.exists() == true)
		{
			return true;
		}
		else
		{
			return false;
		}
	} 

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 03 - JDBC				                                                                                                                         |
---------------------------------------------------------------------------------------------------------------------------------------------------|
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 03 - SECCIÓN 45 - INTRODUCCIÓN A JDBC EN JAVA. 
|  VIDEOS: 172, 173, 174, 175
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Añadir los conectores de BBDD tanto de MySQL y Oracle al proyecto Java.

	- Las dos librerias que hay que importar para que pueda conectar con las BBDD son:
	
		* Conector MySQL: mysql-connector-j-8.0.33.jar
		* Conector Oracle: ojdbc11.jar
		
		Estas dos librerías se encuentran en la misma carpeta donde 
		
	- Para importarlas al proyecto, hay que realizar las siguientes acciones:
	
		1) Botón derecho sobre el nombre del proyecto -> Properties -> Java Build Path -> Libraries -> Pulsar en "Add External JARs.." -> Se busca las
			 dos librerias en esta misma carpeta y se debe de añadir correctamente al proyecto.
		2) En el archivo "pom.xml" del proyecto Maven se debe de incluir las siguientes líneas justo antes del comando "</project>" y se guarda:
	
			<dependencies>
		    <dependency>
		      <groupId>mysql</groupId>
		      <artifactId>mysql-connector-java</artifactId>
		      <version>8.0.23</version>
		    </dependency>
		    <dependency>
		      <groupId>com.oracle.database.jdbc</groupId>
		      <artifactId>ojdbc10</artifactId>
		      <version>19.3.0.0</version>
		    </dependency>
		  </dependencies>
		
		Una vez que ya tenemos los enlaces creados entre las BBDD y Eclipse, pues hay que crear la clase "Conexion_BBDD.java" para realizar la 
		conexión.
		
2. Creación de la clase "Conexion_BBDD", la cual nos va a permitir tener una conexión con la BBDD tanto de MySQL como de Oracle.

	import java.sql.Connection;
	import java.sql.PreparedStatement;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	
	import javax.sql.DataSource;
	
	import org.apache.commons.dbcp2.BasicDataSource;
	
	// Declaración de la clase para la conexión con las BBDD de MySQL y Oracle.
	public class Conexion_BBDD 
	{
	  
	  // Declaración de los atributos de la clase.
	  
	  // Tipo de BBDD a conectar.
	  private String tipoBBDD;
	  // Creación del objeto de conexión de BBDD.
	  private Connection conexion;
	  // Cadena de conexión a la BBDD.
	  private String url;
	  // Usuario de la BBDD.
	  private String usuario; 
	  // Contraseña de la BBDD.
	  private String clave;
	  // Valor de Class.forName().
	  private String classforname;
	  // Variable para el Pool de conexiones.
	  private BasicDataSource pool = null;
	  
	  // Declaración del constructor para inicializar los atributos de clase utilizados para la conexión con la BBDD.
	  public Conexion_BBDD(String tipoBBDD)
	  {
	    // Se carga el atributo de clase con el valor que le venga en la creación del objeto de la clase "Conexion_BBDD".
	    this.tipoBBDD = tipoBBDD;
	    
	    // Segón sea la BBDD a conectar, pues se carga las variables necesarias para la conexión con dicha BBDD.
	    switch (this.tipoBBDD) 
	    {
	      
	      // Variables para la conexión con la BBDD de MySQL.
	      case "MySQL":
	        this.conexion = null;
	        this.url = "jdbc:mysql://localhost:3306/test?useSSL=false&useTimezone=true&serverTimezone=UTC&allowPublicKeyRetrieval=true";
	        this.usuario = "root";
	        this.clave = "admin"; 
	        this.classforname = "com.mysql.cj.jdbc.Driver";
	        break; 
	        
	      // Variables para la conexión con la BBDD de Oracle.
	      case "Oracle":
	        this.conexion = null;
	        this.url = "jdbc:oracle:thin:@localhost:1521:xe";
	        this.usuario = "Curso_Java";
	        this.clave = "1234"; 
	        this.classforname = "oracle.jdbc.driver.OracleDriver";
	        break; 
	    }
	  }
	  
	  // Se crea el método en el cual se realiza la conexión con la BBDD.
	  public Connection crearConexionBBDD()
	  {
	    // Se mete el código en un bloque "try catch".
	    try 
	    {
	      
	      Class.forName(this.classforname);
	      
	      // Se crea un objeto de tipo Conexion donde se pasa la url, el usuario y la clave de la BBDD usando el Pool de conexiones "getDataSource()".
	      this.conexion = getDataSource().getConnection();  
	      
	      // Se informa si la conexión a la BBDD ha sido correcta o no.
	      if (this.conexion != null) 
	      {
	      	System.out.println("\nINFORMACIÓN: BBDD " + this.tipoBBDD + " - Conexión exitosa.");
	      }
	      else
	      {
	        System.out.println("\nERROR: BBDD " + this.tipoBBDD + " - Conexión errónea.");
	      }
	    }
	    // Si llega un mensaje de error, se muestra por consola.
	    catch (ClassNotFoundException | SQLException w_error) 
	    {
	      System.out.println("\nERROR: BBDD " + this.tipoBBDD + " - Conexión errónea: " + w_error.getMessage());
	    }    
	    // Se retorna el objeto tipo conexión.
	    return this.conexion;
	  }
	
	  // Creación del método para inicializar el Pool de conexiones.
	  public DataSource getDataSource()
	  {
	  	// Si no se ha creado ningun Pool de conexiones, se crea.
	  	if (pool == null)
	  	{
	  	
		  	// Número de conexiones a abrir con el Pool.
		  	int numPoolConexiones = 5;
		  	
		  	// Creamos un objeto de tipo BasicDataSource.
		  	pool = new BasicDataSource();
		  	
		  	// Le asignamos las variables de la URL, Usuario y clave de la BBDD a conectar.
		  	pool.setUrl(this.url);
		  	pool.setUsername(usuario);
		  	pool.setPassword(clave);
		  	
		  	// Definimos el tamaño inicial del Pool de conexiones.
		  	pool.setInitialSize(numPoolConexiones);
		  
	  	}
	  	// Retorna el pool.
	  	return pool;
	  	
	  }
	
	  // Creación del método para cerrar el registro de tipo "ResultSet".
	  public void cerrar(ResultSet registro)
	  {
	  	// Se mete el código en un bloque "try catch".
	  	try 
	  	{
	  		// Se cierra el registro de tipo "ResultSet".
	  		registro.close();            
	  	} 
	  	// Si llega un mensaje de error, se muestra por consola.
	  	catch (SQLException w_error) 
	  	{
	  		System.out.println("\nERROR: BBDD " + this.tipoBBDD + " - Error de desconexión ResultSet: " + w_error.getMessage());
	  	}
	  }
	
	  // Creación del método para cerrar la instrucción de tipo "PreparedStatement".
	  public void cerrar(PreparedStatement instruccion)
	  {
	    // Se mete el código en un bloque "try catch".
	    try 
	    {
	      // Se cierra la instrucción de tipo "PreparedStatement".
	    	instruccion.close();            
	    } 
	    // Si llega un mensaje de error, se muestra por consola.
	    catch (SQLException w_error) 
	    {
	      System.out.println("\nERROR: BBDD " + this.tipoBBDD + " - Error de desconexión PreparedStatement: " + w_error.getMessage());
	    }
	  }
	  
	  // Creación del método para desconectar la conexión de BBDD.
	  public void desconexion()
	  {
	    // Se mete el código en un bloque "try catch".
	    try 
	    {
	      // Se cierra la conexión con la BBDD.
	      this.conexion.close();      
	    } 
	    // Si llega un mensaje de error, se muestra por consola.
	    catch (SQLException w_error) 
	    {
	      System.out.println("\nERROR: BBDD " + this.tipoBBDD + " - Error de desconexión: " + w_error.getMessage());
	    }
	  }
	}

2. Uso de la clase "Conexion_BBDD".

2.1. La Base de datos es MySQL.

	import java.sql.*;
	
	public class PruebaConexionMySQL 
	{
	  public static void main(String[] args) 
	  {
	  	
	    // Se crea un objeto de tipo "Conexion_MySQL" que se va a utilizar para la conexión con la BBDD indicando que la BBDD va a ser MySQL.
	    Conexion_BBDD conexionMySQL = new Conexion_BBDD("MySQL");
	        
	    // Se mete el código en un bloque "try catch".
	    try 
	    {
	    	
	    	// Se llama al método que realiza la conexión con la BBDD de MySql.
	      Connection conexion = conexionMySQL.crearConexionBBDD();
	      
	    	// Declaración de variables que van a contener cada una de las sentencias a ejecutar.
	      String sql = "SELECT idpersona, nombre, apellidos, email, telefono FROM persona ORDER BY idpersona";
	      
	      // Se crea la sentencia que se va a lanzar en la BBDD.
	      PreparedStatement instruccion = conexion.prepareStatement(sql);
	      
	      // Se lanza la sentencia en BBDD y se guarda el resultado.
	      ResultSet resultado = instruccion.executeQuery(sql);
	      
	      System.out.println("\nDATOS DE LA PERSONA\n");
	      
	      // Se recorre todos los registros recuperados, se muestran por consola y se muestra por pantalla.
	      while(resultado.next())
	      {
	        System.out.println("- ID Persona: " + resultado.getInt("idpersona"));
	        System.out.println("- Nombre: " + resultado.getString("nombre"));
	        System.out.println("- Apellidos: " + resultado.getString("apellidos"));
	        System.out.println("- Email: " + resultado.getString("email"));
	        System.out.println("- Teléfono: " + resultado.getString("telefono") + "\n");
	      }
	      
	      // Se cierran las conexiones.
	      conexionMySQL.cerrar(resultado);
	      conexionMySQL.cerrar(instruccion);
	      conexionMySQL.desconexion();
	
	    } 
	    // Si llega un mensaje de error, se muestra por consola.
	    catch (SQLException ex) 
	    {
	      System.out.println("ERROR SQL: " + ex.getMessage());
	    }
	  } 
	}

2.2. La Base de datos es Oracle.

	import java.sql.Connection;
	import java.sql.PreparedStatement;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import java.util.ArrayList;
	import java.util.List;
	
	// Declaración de la clase DAO de Persona.
	public class PersonaDAO 
	{
		
		// Declaración de variables que van a contener cada una de las sentencias a ejecutar.
		
		private static final String SQL_SELECT = "SELECT idpersona, nombre, apellidos, email, telefono FROM persona ORDER BY idpersona";
		
		// Declaración de los métodos.
		
		// Declaración del método que va a realizar la consulta completa a la tabla de Persona y la va a guardar en una lista de tipo "Persona".
		public List<Persona> consultaPersona()
		{
			
		// Definición de las variables.
			
			// Se crea un objeto de tipo "Conexion_Oracle" que se va a utilizar para la conexión con la BBDD indicando que la BBDD va a ser Oracle.
			Conexion_BBDD conexionOracle = new Conexion_BBDD("Oracle");
			// Se crea un objeto de tipo "Connection" para almacenar la conexión con la BBDD.
			Connection conexion = null;
			// Almacena la sentencia que se va a ejecutar en la BBDD.
			PreparedStatement instruccion = null;
			// Almacena un registro de la tabla Persona.
			ResultSet registro = null;		
			// Se crea un objeto de tipo Persona para almacenar cada registro recuperado de la tabla Persona.
			Persona registroPersona = null;
			// Se crea una lista de tipo Persona para almacenar todos los registros recuperados de la tabla Persona.
			List<Persona> listaPersonas = new ArrayList<Persona>();
	
	    // Se mete el código en un bloque "try catch" para contemplar el error "SQLException".
	    try 
			{
	    	
	      // Se llama al método que realiza la conexión con la BBDD de Oracle y se devuelve el objeto de tipo Connection a la variable "conexión". 
	      conexion = conexionOracle.crearConexionBBDD();
	      
	    	// Se crea la sentencia que se va a lanzar en la BBDD.
	    	instruccion = conexion.prepareStatement(SQL_SELECT);
				
	    	// Se lanza la sentencia en BBDD y se guarda el resultado.
	    	registro = instruccion.executeQuery();
				
	    	System.out.println("\n-------------------");
				System.out.println("DATOS DE LA PERSONA");
				System.out.println("-------------------\n");
				
				// Se recorre todos los registros recuperados, se muestran por consola y se añade cada registro en la lista de Persona.
				while(registro.next() == true)
				{
					
					// Se guarda cada campo en una variable para luego usarla.
					int 	 reg_idPersona 	= registro.getInt("idpersona");
					String reg_nombre 		= registro.getString("nombre");
					String reg_apellidos 	= registro.getString("apellidos");
					String reg_email 			= registro.getString("email");
					String reg_telefono 	= registro.getString("telefono");
	        
	        // Se crea un objeto de tipo Persona utilizando el constructor completo.
	        registroPersona = new Persona(reg_idPersona, 
														        		reg_nombre, 
														        		reg_apellidos, 
														        		reg_email, 
														        		reg_telefono);
	        
	        // Se añade cada registro de la tabla Persona en la lista "listaPersonas".
	        listaPersonas.add(registroPersona);
	        
	        // Se imprime los datos por consola.
	        registroPersona.toString();
				}			
			} 
			// Si llega un mensaje de error, se muestra por consola.
			catch (SQLException w_error) 
			{
				System.out.println("ERROR SQL: " + w_error.getMessage());
			}
	    // Se cierra todas las conexiones.
			finally
			{			
				// Se cierra el registro, la instrucción y se desconecta de la BBDD.
				conexionOracle.cerrar(registro);
				conexionOracle.cerrar(instruccion);
				conexionOracle.desconexion();
			}
	    
	    // Se retorna la lista de registros de la tabla Persona.
			return listaPersonas;
		}
	}

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 03 - SECCIÓN 47 - TRANSACCIONES CON JDBC EN JAVA. 
|  VIDEOS: 187, 188, 189
---------------------------------------------------------------------------------------------------------------------------------------------------|

	Una transacción es un conjunto de sentencias SQL las cuales son agrupadas en bloques de ejecución, si alguna de las instrucciones falla se puede
	dar marcha atrás ejecutando con "Rollback" a todo el bloque ejecutado pero si está todo correcto, se realiza un Commit de todo el bloque 
	ejecutado.
	
	Los métodos que se pueden usar en una transacción son:
	
		- autocommit (Valores true o false): Realiza o no un commit de manera automática en cada instrucción.
								 Este método por default tiene el valor "true" por lo que es recomendable al inicio indicar este valor a "false".
		- commit: Guarda los cambios en la BBDD del bloque de ejecución.
		- rollback: Revierte los cambios realizados por el bloque de ejecución.
								Se suele utilizar en los bloques "try catch".
	
	Importante: Si cerramos la conexión de JDBC se realiza un Commit, incluso si se deshabilitó la propiedad autocommit.
	
Los pasos para implementar las transacciones con JDBC son:

- En la clase que implementa los distintos métodos de operaciones tipo SQL se debe de realizar las siguientes acciones:

	1) Declaración de una variable tipo "Connection" para implementar la transacción.

		Connection conexionTransaccion = null;

	2) Creación de un constructor el cual recibe como argumento el atributo de clase de transacción para su inicialización.

		// Declaración de un constructor para inicializar el valor de la conexión de transacción.
		public UsuarioDAO(Connection conexionTransaccion)
		{
			this.conexionTransaccion = conexionTransaccion;
		}
	
	3) Cuando se asigna a la variable de conexión la creación de la conexión en sí, se debe de preguntar antes si existe una conexión ya creada
		 o no, porque si existe se mantiene la conexión que existe y sino pues se crea una nueva conexión con la BBDD.
		
		Connection conexion = null;
		
		// Si ya existe una conexión a la BBDD se mantiene dicha conexión, sino, pues se crea una nueva conexión a la BBDD.
		
		if (this.conexionTransaccion != null)
		{
			conexion = this.conexionTransaccion;
		}
		else
		{
			conexion = conexionOracle.crearConexionBBDD();	
		}
	
	4) No se debe de indicar el catch del bloque try, sino que solo tendrá el bloque "try finally" ya que la excepción de va a propagar en la
		 declaración del método hacia la clase que llame a ésta utilizando para ello la palabra "throws SQLException".
		 
	5) En el bloque "finally", se comprueba si se ha creado la conexión en el inicio del método en el que se encuentra, ya que si es así, pues
		 cierra la conexión con la BBDD, pero sino, pues continua con la conexión. 
	
			if (this.conexionTransaccion == null)
			{
				conexionOracle.desconexion();
			}

- En la clase que se esta usando los métodos para las operaciones SQL se debe de realizar las siguientes acciones:

	1) Se debe de declarar dos variables para almacenar la conexión de la BBDD.
	
			Conexion_BBDD conexionOracle = null;
			Connection conexion = null;
			
	2) Se realiza la conexión con la BBDD igual que en la clase de los métodos.
	
			conexionOracle = new Conexion_BBDD("Oracle");
			conexion = conexionOracle.crearConexionBBDD();
	
	3) Se comprueba si está la función "autocommit" esta activada y si es así, se desactiva.
	
			if (conexion.getAutoCommit() == true)
			{
				conexion.setAutoCommit(false);
			}
	
	4) Se crea el objeto de la clase que almacena los métodos SQL y se le pasa la conexión para utilizar el constructor nuevo creado 
		 anteriomente.
	
			usuarioDAO = new UsuarioDAO(conexion);
	
	5) Se crea en el bloque "try" el bloque "catch" para la excepción "SQLException" en la cual se incluye otro bloque "try catch" para utilizar
		 la sentencia "conexion.rollback()" y así si se da un error, pues se hace el Rollback para anular todos los cambios realizados durante toda
		 la sesión de la BBDD.
	
			catch (SQLException w_error) 
			{
				System.out.println("ERROR: Error en sentencia SQL: " + w_error.getMessage());
				System.out.println("AVISO: Se va a realizar el Rollback de todos los cambios realizados.");
				
				// Se utiliza un bloque "try catch" para enmascarar el error "SQLException" que puede producirse por el Rollback.
				try 
				{
					conexion.rollback();
				} 
				catch (SQLException w_errorRollback) 
				{
					System.out.println("\nERROR: Error en el Rollback de los datos: " + w_errorRollback.getMessage());
				}
			}
		
	6) En la zona del código que se necesite guardar los cambios, se utiliza la sentencia "conexion.commit()" para comitar todos los cambios 
		 realizados durante toda la sesión de la BBDD.
	
			conexion.commit();
			System.out.println("\nINFORMACIÓN: Se han guardado todos las modificaciones realizadas de forma correcta.");

Se incluyen las 3 clases que se ha utilizado para el Laboratorio de la sección 48 "Patrones Disenio".

1. Interface IUsuario.
	
	import java.sql.SQLException;
	
	import Seccion48_PatronesDisenio.personas.dto.UsuarioDto;
	
	public interface IUsuarioDao 
	{
		
		// Declaración de los métodos de la interface "IUsuarioDAO".
		
		public abstract void consultarUsuarios() throws SQLException;
		public abstract void insertarUsuarios(UsuarioDto usuario) throws SQLException;
		public abstract void actualizarUsuarios(UsuarioDto usuario) throws SQLException;
		public abstract void eliminarUsuarios(UsuarioDto usuario) throws SQLException;
		
	}
	
2. Clase UsuarioDaoJDBC en la que existen los métodos de las consultas SQL.

	import java.sql.Connection;
	import java.sql.PreparedStatement;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import java.util.ArrayList;
	import java.util.List;
	
	import Seccion48_PatronesDisenio.personas.dto.UsuarioDto;
	
	
	// Declaración de la clase "UsuarioDaoJDBC" que es la implementación de la interface "IUsuarioDAO".
	
	public class UsuarioDaoJDBC implements IUsuarioDao
	{
		
		// Declaración de las variables necesarias.
		
		Conexion_BBDD conexionOracle = null;
		Connection conexion = null;
		PreparedStatement instruccion = null;
		UsuarioDto usuario = null;
		ResultSet registro = null;
		Connection conexionTransaccion = null;
		
		// Declaración de las variables con las sentencias a ejecutar en BBDD.
		
		public static final String SQL_SELECT = "SELECT idusuario, username, password FROM usuario ORDER BY idusuario";
		public static final String SQL_INSERT = "INSERT INTO usuario (username, password) VALUES (?, ?)";
		public static final String SQL_UPDATE = "UPDATE usuario SET username = ?, password = ? WHERE idusuario = ?";
		public static final String SQL_DELETE = "DELETE FROM usuario WHERE idusuario = ?";
		
		public UsuarioDaoJDBC()
		{}
		
		// Declaración de un constructor para poder recibir el valor de la conexión de transacción.
		public UsuarioDaoJDBC(Connection conexionTransaccion)
		{
			this.conexionTransaccion = conexionTransaccion;
		}
		
		// Declaración del método "consultarUsuario()".
		
		public void consultarUsuarios() throws SQLException 
		{
			
			List<UsuarioDto> listaUsuario = new ArrayList<UsuarioDto>();
			
			// Se crea un bloque "try catch" para enmascarar el error "SQLException".
			try 
			{
	
				// Se crea la conexión, se lanza la sentencia SQL de consulta y todos los registros se añaden a la lista de Usuarios para luego imprimirlos 
				// por consola.
				
				conexionOracle = new Conexion_BBDD("Oracle");
				
				// Si ya existe una conexión a la BBDD se mantiene dicha conexión, sino, pues se crea una nueva conexión a la BBDD.
				if (this.conexionTransaccion != null)
				{
					conexion = this.conexionTransaccion;
				}
				else
				{
					conexion = conexionOracle.crearConexionBBDD();	
				}
				
				instruccion = conexion.prepareStatement(SQL_SELECT);
				registro = instruccion.executeQuery();
				
				System.out.println("\n-----------------");
				System.out.println("LISTA DE USUARIOS");
				System.out.println("-----------------\n");
				
				while (registro.next() == true)
				{			
					int reg_idUsuario = registro.getInt("idUsuario");
					String reg_Usuario = registro.getString("username");
					String reg_Password = registro.getString("password");
					
					usuario = new UsuarioDto(reg_idUsuario, reg_Usuario, reg_Password);				
					listaUsuario.add(usuario);				
				}
				
				for (UsuarioDto regUsuario : listaUsuario) 
				{
					System.out.println(regUsuario.toString());
				}
				
			}
			// Se desconectan los elementos creados y la conexión, si ha sido creada en éste método.
			finally
			{
				conexionOracle.cerrar(registro);
				conexionOracle.cerrar(instruccion);
				
				if (this.conexionTransaccion == null)
				{
					conexionOracle.desconexion();
				}
			}
		}
		
		// Declaración del método "insertarUsuarios()".
		
		public void insertarUsuarios(UsuarioDto usuario) throws SQLException 
		{
			
			int numRegistro = 0;
			
			// Se crea la conexión, se lanza la sentencia INSERT con los parámetros necesarios y se informa por consola.
			try 
			{
				conexionOracle = new Conexion_BBDD("Oracle");
	
				// Si ya existe una conexión a la BBDD se mantiene dicha conexión, sino, pues se crea una nueva conexión a la BBDD.
				if (this.conexionTransaccion != null)
				{
					conexion = this.conexionTransaccion;
				}
				else
				{
					conexion = conexionOracle.crearConexionBBDD();	
				}
						
				instruccion = conexion.prepareStatement(SQL_INSERT);
				
				instruccion.setString(1, usuario.getUsername());
				instruccion.setString(2, usuario.getPassword());
				
				numRegistro = instruccion.executeUpdate();
				
				System.out.println("\nINFORMACIÓN: Se ha insertado " + numRegistro + " registro en la tabla Usuario.");
	
				// Se lanza de nuevo la consulta de datos.
				consultarUsuarios();
				
			} 
			// Se desconectan los elementos creados y la conexión, si ha sido creada en éste método.
			finally
			{
				conexionOracle.cerrar(instruccion);
				
				if (this.conexionTransaccion == null)
				{
					conexionOracle.desconexion();
				}
			}	
		}
		
		// Declaración del método "actualizarUsuarios()".
		
		public void actualizarUsuarios(UsuarioDto usuario) throws SQLException 
		{
			
			int numRegistro = 0;
			
			// Se crea la conexión, se lanza la sentencia UPDATE con los parámetros necesarios y se informa por consola.
			try 
			{
				conexionOracle = new Conexion_BBDD("Oracle");
	
				// Si ya existe una conexión a la BBDD se mantiene dicha conexión, sino, pues se crea una nueva conexión a la BBDD.
				if (this.conexionTransaccion != null)
				{
					conexion = this.conexionTransaccion;
				}
				else
				{
					conexion = conexionOracle.crearConexionBBDD();	
				}
						
				instruccion = conexion.prepareStatement(SQL_UPDATE);
	
				instruccion.setString(1, usuario.getUsername());
				instruccion.setString(2, usuario.getPassword());
				instruccion.setInt(3, usuario.getIdUsuario());
				
				numRegistro = instruccion.executeUpdate();
				
				System.out.println("\nINFORMACIÓN: Se ha actualizado " + numRegistro + " registro de la tabla Usuario.");
				
				// Se lanza de nuevo la consulta de datos.
				consultarUsuarios();
				
			} 
			// Se desconectan los elementos creados y la conexión, si ha sido creada en éste método.
			finally
			{
				conexionOracle.cerrar(instruccion);
				
				if (this.conexionTransaccion == null)
				{
					conexionOracle.desconexion();
				}
			}
		}
	
		// Declaración del método "eliminarUsuarios()".
		
		public void eliminarUsuarios(UsuarioDto usuario) throws SQLException 
		{
			int numRegistro = 0;
			
			// Se crea la conexión, se lanza la sentencia DELETE con el parámetro necesario y se informa por consola.
			try 
			{
				conexionOracle = new Conexion_BBDD("Oracle");
	
				// Si ya existe una conexión a la BBDD se mantiene dicha conexión, sino, pues se crea una nueva conexión a la BBDD.
				if (this.conexionTransaccion != null)
				{
					conexion = this.conexionTransaccion;
				}
				else
				{
					conexion = conexionOracle.crearConexionBBDD();	
				}
						
				instruccion = conexion.prepareStatement(SQL_DELETE);
				
				instruccion.setInt(1, usuario.getIdUsuario());
				
				numRegistro = instruccion.executeUpdate();
				
				System.out.println("\nINFORMACIÓN: Se ha eliminado " + numRegistro + " registro de la tabla Usuario.");
				
				consultarUsuarios();	
			} 	
			// Se desconectan los elementos creados y la conexión, si ha sido creada en éste método.
			finally
			{
				conexionOracle.cerrar(instruccion);
				
				if (this.conexionTransaccion == null)
				{
					conexionOracle.desconexion();
				}
			}		
		}
	}

3. Clase en la que se ejecutan los métodos de las sentencias SQL.

	import java.sql.Connection;
	import java.sql.SQLException;
	import java.util.Scanner;
	
	import Seccion48_PatronesDisenio.personas.dto.UsuarioDto;
	import Seccion48_PatronesDisenio.personas.jdbc.Conexion_BBDD;
	import Seccion48_PatronesDisenio.personas.jdbc.IUsuarioDao;
	import Seccion48_PatronesDisenio.personas.jdbc.UsuarioDaoJDBC;
	
	public class TestUsuarios 
	{
	
		public static void main(String[] args) 
		{
			
			// Declaración de las variables necesarias.
			
			int opcion = 0;
			int idUsuarioActualizar = 0;
			int idUsuarioEliminar = 0;
			Scanner datosConsola = null;
			IUsuarioDao usuarioDAO = null;
			Conexion_BBDD conexionOracle = null;
			Connection conexion = null;
			
			try 
			{
				// Se crea una conexión con la BBDD.
				conexionOracle = new Conexion_BBDD("Oracle");
				conexion = conexionOracle.crearConexionBBDD();
				
				// Se comprueba si está la función "autocommit" esta activada y si es así, se desactiva.
				if (conexion.getAutoCommit() == true)
				{
					conexion.setAutoCommit(false);
				}
				
				// Creación de un objeto de tipo UsuarioDAO pasandole la conexión realizada.
				usuarioDAO = new UsuarioDaoJDBC(conexion);
				
				while(opcion != 6)
				{
					
					System.out.println("\n--------------------------------------------------");
					System.out.println("BIENVENIDOS A LA APLICACIÓN DE GESTIÓN DE USUARIOS");
					System.out.println("--------------------------------------------------");
					System.out.println("\nMENÚ");
					System.out.println("\n  1.- Consultar todos los usuarios.");	
					System.out.println("  2.- Insertar un nuevo usuario.");		
					System.out.println("  3.- Actualizar un usuario.");		
					System.out.println("  4.- Eliminar un usuario.");				
					System.out.println("  5.- Guardar todos los cambios realizados a los datos de los usuarios.");
					System.out.println("  6.- Salir.");		
					
					// Se pide al usuario que introduzca la opción del menú que quiere realizar.
					System.out.print("\n- Introduzca la opción: ");
					datosConsola = new Scanner(System.in);
					opcion = Integer.parseInt(datosConsola.nextLine());
					
					// Según la opción elegida.
					switch (opcion) 
					{
						
						// 1. Prueba sobre el método "consultarUsuarios()".
						case 1:
							
							usuarioDAO.consultarUsuarios();
							break;
						
						// 2. Prueba sobre el método "insertarUsuarios()".
						case 2: 
							
							UsuarioDto usuarioInsertar = new UsuarioDto("Alex", "alexlopez");
							usuarioDAO.insertarUsuarios(usuarioInsertar);
							break;
						
						// 3. Prueba sobre el método "usuarioActualizar()".
						case 3:
							
							// Se muestran todos los usuarios existentes.
							usuarioDAO.consultarUsuarios();
							
							// Se solicita indicar el usuario a actualizar.
							System.out.print("\n- Introduzca el ID del usuario a modificar: ");
							datosConsola = new Scanner(System.in);
							idUsuarioActualizar = Integer.parseInt(datosConsola.nextLine());
							
							// Se actualiza el usuario indicado.
							UsuarioDto usuarioActualizar = new UsuarioDto(idUsuarioActualizar, "alexito", "peke062022");
							usuarioDAO.actualizarUsuarios(usuarioActualizar);
							break;
						
						// 4. Prueba sobre el método "eliminarUsuarios()".
						case 4:
							
							// Se muestran todos los usuarios existentes.
							usuarioDAO.consultarUsuarios();
							
							// Se solicita indicar el usuario a eliminar.
							System.out.print("\n- Introduzca el ID del usuario a eliminar: ");
							datosConsola = new Scanner(System.in);
							idUsuarioEliminar = Integer.parseInt(datosConsola.nextLine());
							
							// Se elimina el usuario indicado.
							UsuarioDto usuarioEliminar = new UsuarioDto(idUsuarioEliminar);
							usuarioDAO.eliminarUsuarios(usuarioEliminar);
							break;
						
						// 5. Guardar los datos.
						case 5:
							
							// Se guardan los datos en la BBDD.
							conexion.commit();
							System.out.println("\nINFORMACIÓN: Se han guardado todos las modificaciones realizadas de forma correcta.");
							break;
							
						// 6. Salir de la aplicación.
						case 6:
							
							System.out.println("\nINFORMACIÓN: Cierre de la aplicación \"Gestión de Usuarios\".");
							break;
						
						// Error de la aplicación.
						default:
							
							System.out.println("\nERROR: No se reconoce la opción insertada.");
							break;
					}
				}			
			} 
			catch (SQLException w_error) 
			{
				System.out.println("ERROR: Error en sentencia SQL: " + w_error.getMessage());
				System.out.println("AVISO: Se va a realizar el Rollback de todos los cambios realizados.");
				
				// Se utiliza un bloque "try catch" para enmascarar el error "SQLException" que puede producirse por el Rollback.
				try 
				{
					conexion.rollback();
				} 
				catch (SQLException w_errorRollback) 
				{
					System.out.println("\nERROR: Error en el Rollback de los datos: " + w_errorRollback.getMessage());
				}
			}
		}
	}

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 03 - SECCIÓN 48 - PATRONES DE DISEÑO (CAPA DE DATOS) CON JDBC EN JAVA. 
|  VIDEOS: 190, 191
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Capas de diseño.

	Cuando estamos trabajando con Java en una arquitectura Java empresarial, es común que la aplicación se divida en varias capas y cada una es 
	responsable de realizar tareas en específico para así minimizar los costos de desarrollo.
	
	En Java existen muchas capas pero las tres capas de diseño mas importantes y que se intercomunican entre ellas para poder procesar la 
	información son:
	
		- Capa de Presentación: Se encarga de administrar el flujo entre las distintas pantallas del sistema así como de procesar los datos del 
														usuario, es decir los formularios, y desplegar la información al usuario. 
		- Capa de Negocio o Servicio: Se encarga de procesar la lógica de negocio y los servicios que debe manejar nuestro sistema.
		- Cada de Acceso a Datos: Se encarga de obtener y guardar la información de las fuentes de datos con la base de datos, archivos, etc.
		
2. Cohesion y Acoplamiento.

	El tema de cohesión y acoplamiento juegan un rol central en el diseño de software al diseñar nuestros módulos de software.
	
	- Cohesion: Es la medida en la que un componente de software se dedica a realizar solamente una tarea para la cual fue creado, delegando las 
							tareas complementarias a otros componentes.
	- Acoplamiento: Es la medida en que los cambios de un componente tienden a necesitar cambios de otro componente, es decir, que el acoplamiento 
									mide el grado de dependencia entre dos o más elementos, ya que éstos pueden ser clases o cualquier otro tipo de componentes 
									de software.
									
	El objetivo del diseño de software es tener una alta cohesión y un bajo acoplamiento entre sus componentes, por lo que estas son dos 
	características que debemos de tener en cuenta al momento de crear nuestras aplicaciones..
	
	La división en capas de manera lógica en una arquitectura Java empresarial introduce un bajo acoplamiento y una alta cohesión de manera 
	automática debido a que permite que el número de relaciones entre cada capa sea el menor posible y aumente la cohesión en cada capa debido a
	que tenemos una división de responsabilidades de manera muy específica y clara.
	
3. Patrones de diseño.

	Un patrón de diseño es una guía que puede involucrar a varias clases y que a su vez nos permite resolver un problema que se presenta de manera
	repetitiva por lo que la capa de presentación, la capa de servicio y la capa de acceso a datos pueden tener varios patrones de diseño.	
	
	Los patrones de diseño que pueden tener cada una de las capas son:
	
		- Capa de Presentación. 
		
			* Patrón MVC (Model View Controller): Este patrón significa modelo vista controlador y su objetivo es dividir las responsabilidades entre 
																						estos tres elementos (modelo, vista y controlador). 
			* Patrón Font Controler: Nos permite proporcionar una entrada única a nuestra aplicación cuando el usuario hace una petición y por lo tanto
										 					 aquí podemos aplicar varias características, como puede ser algún tipo de seguridad, validaciones, etc. 
			* Patrón DTO (Data Transfer Object): Representa un objeto del dominio del problema utilizandose para transferir una entidad o una lista de 
																					 entidades de cierto tipo entre las distintas capas de la aplicación.
																					 En ocasiones puede ser una clase de entidad (clase que se existe o guarda en una BBDD).
																					 																					 	
			Ejemplo: Un usuario solicita un listado de personas.
						 
				1) La capa de presentación procesa la petición y solicita posteriormente a la capa de servicio que ejecute el método "Encontrar listado de 
					 personas".
				2) La capa de servicio accede a la capa de datos para que podamos recuperar el listado de personas y posteriormente vamos a regresar un 
					 listado de objetos de persona utilizando estos objetos DTO (objeto de tipo Persona).
				3) Comenzamos a regresar la información hasta que damos una respuesta al usuario con el listado de personas que ha solicitado.
		
		- Capa de Negocio.
		
			* Patrón Bussiness Delegate: Se encarga de los detalles de llamar a algún método de servicio.
			* Patrón Service Locator: Es utilizado por el patrón "Bussiness Delegate" para localizar los servicios si es que se encuentran en algún 
																directorio, como puede ser algún directorio de tipo JNDI (Java Naming and Directory Interface) y es una API de JAVA
																para ubicar un directorio de servicios.
			* Patrón DTO (Data Transfer Object): Representa un objeto del dominio del problema utilizandose para transferir una entidad o una lista de 
																					 entidades de cierto tipo entre las distintas capas de la aplicación.
																					 En ocasiones puede ser una clase de entidad (clase que se existe o guarda en una BBDD).
		- Capa de Acceso a Datos.
		
			* Patrón DAO (Data Access Object): Se encarga de extraer y almacenar información en la BBDD.
			* Patrón DTO (Data Transfer Object): Representa un objeto del dominio del problema utilizandose para transferir una entidad o una lista de 
																					 entidades de cierto tipo entre las distintas capas de la aplicación.
																					 En ocasiones puede ser una clase de entidad (clase que se existe o guarda en una BBDD).

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 03 - SECCIÓN 49 - POOL DE CONEXIONES CON JDBC EN JAVA. 
|  VIDEOS: 192, 193
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Pool de conexiones (Video 192).

	Un Pool de conexiones nos permite agilizar el proceso de obtener una conexión por cada clase Java que necesita de una conexión ya que el 
	objetivo del pull de conexiones precisamente es tener listas varias conexiones a la base de datos de manera que sea mucho más eficiente el 
	proceso de obtener y liberar una conexión a la base de datos.
	
	De hecho el proceso de administración de una conexión se delega al pull de conexiones por lo que podemos dejar de preocuparnos por abrir y 
	cerrar una conexión ya que este tipo de tareas entre otras se encargará precisamente el pull de conexiones.
	
	Un Pool de conexiones puede crearse de varias maneras:
	
		- Directamente por código Java que nosotros desarrollemos y que debemos de mantener.
		- Utilizar algún proyecto como el proyecto de JDBC de Apache llamado Apache Commons que es el que utilizamos en este curso.
		- Apoyándonos del servidor de aplicaciones Java cómo puede ser Tomcat, Glassfish, etc.
		
2. Uso del proyecto Apache Commons (Video 193).

	El proyecto Apache Commons es un proyecto de Apache que contiene varias librerías que, como su nombre lo dice, son comunes para todos los 
	proyectos Java y vamos a utilizar el proyecto de "Apache Commons DBCP2" para poder manejar el concepto de pool de conexiones.
	
	Para agregar el proyecto Apache Commons hay que modificar el archivo "pom.xml" añadiendo una nueva dependencia:
	
	  <dependency>
      <groupId>org.apache.commons</groupId>
      <artifactId>commons-dbcp2</artifactId>
      <version>2.7.0</version>
    </dependency>
	
	Una vez que se ha agregado el proyecto Apache a nuestro proyecto hay que realizar los cambios pertinentes en la clase "Conexion_BBDD" y son
	los siguientes:
	
		1) Se declara una variable de tipo "BasicDataSource".
		
		  // Variable para el Pool de conexiones.
  		private BasicDataSource pool = null;
  	
  	2) Se crea un método llamado "getDataSource" que retorna un objeto "DataSource" para inicializar el Pool de 5 conexiones.
  	
  	  // Creación del método para inicializar el Pool de conexiones.
		  public DataSource getDataSource()
		  {
		  	// Si no se ha creado ningun Pool de conexiones, se crea.
		  	if (pool == null)
		  	{
		  	
			  	// Número de conexiones a abrir con el Pool.
			  	int numPoolConexiones = 5;
			  	
			  	// Creamos un objeto de tipo BasicDataSource.
			  	pool = new BasicDataSource();
			  	
			  	// Le asignamos las variables de la URL, Usuario y clave de la BBDD a conectar.
			  	pool.setUrl(this.url);
			  	pool.setUsername(usuario);
			  	pool.setPassword(clave);
			  	
			  	// Definimos el tamaño inicial del Pool de conexiones.
			  	pool.setInitialSize(numPoolConexiones);
			  
		  	}
		  	// Retorna el pool.
		  	return pool;
		  	
		  }
		  
  	3) En el método "crearConexionBBDD()" ya no se llama al método "DriverManager.getConnection()" sino ahora se utiliza el método creado 
  		 "getDataSource()" y se le añade el método "getConnection()".
  		 
  		 // Se crea un objeto de tipo Conexion donde se pasa la url, el usuario y la clave de la BBDD usando el Pool de conexiones "getDataSource()".
       this.conexion = getDataSource().getConnection();
       
	El código de la clase "Conexion_BBDD" actualizada es el siguiente:
	
		import java.sql.Connection;
		import java.sql.PreparedStatement;
		import java.sql.ResultSet;
		import java.sql.SQLException;
		
		import javax.sql.DataSource;
		
		import org.apache.commons.dbcp2.BasicDataSource;
		
		// Declaración de la clase para la conexión con las BBDD de MySQL y Oracle.
		public class Conexion_BBDD 
		{
		  
		  // Declaración de los atributos de la clase.
		  
		  // Tipo de BBDD a conectar.
		  private String tipoBBDD;
		  // Creación del objeto de conexión de BBDD.
		  private Connection conexion;
		  // Cadena de conexión a la BBDD.
		  private String url;
		  // Usuario de la BBDD.
		  private String usuario; 
		  // Contraseña de la BBDD.
		  private String clave;
		  // Valor de Class.forName().
		  private String classforname;
		  // Variable para el Pool de conexiones.
		  private BasicDataSource pool = null;
		  
		  // Declaración del constructor para inicializar los atributos de clase utilizados para la conexión con la BBDD.
		  public Conexion_BBDD(String tipoBBDD)
		  {
		    // Se carga el atributo de clase con el valor que le venga en la creación del objeto de la clase "Conexion_BBDD".
		    this.tipoBBDD = tipoBBDD;
		    
		    // Segón sea la BBDD a conectar, pues se carga las variables necesarias para la conexión con dicha BBDD.
		    switch (this.tipoBBDD) 
		    {
		      
		      // Variables para la conexión con la BBDD de MySQL.
		      case "MySQL":
		        this.conexion = null;
		        this.url = "jdbc:mysql://localhost:3306/test?useSSL=false&useTimezone=true&serverTimezone=UTC&allowPublicKeyRetrieval=true";
		        this.usuario = "root";
		        this.clave = "admin"; 
		        this.classforname = "com.mysql.cj.jdbc.Driver";
		        break; 
		        
		      // Variables para la conexión con la BBDD de Oracle.
		      case "Oracle":
		        this.conexion = null;
		        this.url = "jdbc:oracle:thin:@localhost:1521:xe";
		        this.usuario = "Curso_Java";
		        this.clave = "1234"; 
		        this.classforname = "oracle.jdbc.driver.OracleDriver";
		        break; 
		    }
		  }
		  
		  // Se crea el método en el cual se realiza la conexión con la BBDD.
		  public Connection crearConexionBBDD()
		  {
		    // Se mete el código en un bloque "try catch".
		    try 
		    {
		      
		      Class.forName(this.classforname);
		      
		      // Se crea un objeto de tipo Conexion donde se pasa la url, el usuario y la clave de la BBDD usando el Pool de conexiones "getDataSource()".
		      this.conexion = getDataSource().getConnection();  
		      
		      // Se informa si la conexión a la BBDD ha sido correcta o no.
		      if (this.conexion != null) 
		      {
		      	System.out.println("\nINFORMACIÓN: BBDD " + this.tipoBBDD + " - Conexión exitosa.");
		      }
		      else
		      {
		        System.out.println("\nERROR: BBDD " + this.tipoBBDD + " - Conexión errónea.");
		      }
		    }
		    // Si llega un mensaje de error, se muestra por consola.
		    catch (ClassNotFoundException | SQLException w_error) 
		    {
		      System.out.println("\nERROR: BBDD " + this.tipoBBDD + " - Conexión errónea: " + w_error.getMessage());
		    }    
		    // Se retorna el objeto tipo conexión.
		    return this.conexion;
		  }
		
		  // Creación del método para inicializar el Pool de conexiones.
		  public DataSource getDataSource()
		  {
		  	// Si no se ha creado ningun Pool de conexiones, se crea.
		  	if (pool == null)
		  	{
		  	
			  	// Número de conexiones a abrir con el Pool.
			  	int numPoolConexiones = 5;
			  	
			  	// Creamos un objeto de tipo BasicDataSource.
			  	pool = new BasicDataSource();
			  	
			  	// Le asignamos las variables de la URL, Usuario y clave de la BBDD a conectar.
			  	pool.setUrl(this.url);
			  	pool.setUsername(usuario);
			  	pool.setPassword(clave);
			  	
			  	// Definimos el tamaño inicial del Pool de conexiones.
			  	pool.setInitialSize(numPoolConexiones);
			  
		  	}
		  	// Retorna el pool.
		  	return pool;
		  	
		  }
		
		  // Creación del método para cerrar el registro de tipo "ResultSet".
		  public void cerrar(ResultSet registro)
		  {
		  	// Se mete el código en un bloque "try catch".
		  	try 
		  	{
		  		// Se cierra el registro de tipo "ResultSet".
		  		registro.close();            
		  	} 
		  	// Si llega un mensaje de error, se muestra por consola.
		  	catch (SQLException w_error) 
		  	{
		  		System.out.println("\nERROR: BBDD " + this.tipoBBDD + " - Error de desconexión ResultSet: " + w_error.getMessage());
		  	}
		  }
		
		  // Creación del método para cerrar la instrucción de tipo "PreparedStatement".
		  public void cerrar(PreparedStatement instruccion)
		  {
		    // Se mete el código en un bloque "try catch".
		    try 
		    {
		      // Se cierra la instrucción de tipo "PreparedStatement".
		    	instruccion.close();            
		    } 
		    // Si llega un mensaje de error, se muestra por consola.
		    catch (SQLException w_error) 
		    {
		      System.out.println("\nERROR: BBDD " + this.tipoBBDD + " - Error de desconexión PreparedStatement: " + w_error.getMessage());
		    }
		  }
		  
		  // Creación del método para desconectar la conexión de BBDD.
		  public void desconexion()
		  {
		    // Se mete el código en un bloque "try catch".
		    try 
		    {
		      // Se cierra la conexión con la BBDD.
		      this.conexion.close();      
		    } 
		    // Si llega un mensaje de error, se muestra por consola.
		    catch (SQLException w_error) 
		    {
		      System.out.println("\nERROR: BBDD " + this.tipoBBDD + " - Error de desconexión: " + w_error.getMessage());
		    }
		  }
		}

---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 04 - APLICACIONES GRAFICAS CON SWING                                                                                                     |
---------------------------------------------------------------------------------------------------------------------------------------------------|
---------------------------------------------------------------------------------------------------------------------------------------------------|
|  BLOQUE 04 - APLICACIONES GRAFICAS CON SWING - SECCIÓN 01 - ELEMENTO JFRAME DE JAVA
|  VIDEO: 55, 56, 57. 
|	 Lista de reproducción: https://www.youtube.com/playlist?list=PLU8oAlHdN5BktAXdEVCLUYzvDyqRQJ2lk
---------------------------------------------------------------------------------------------------------------------------------------------------|

1. Definición Paquete javax.swing (Video 55). 
	
	- Swing es una biblioteca gráfica para Java que incluye widgets para interfaz gráfica de usuario tales como cajas de texto, botones, listas 
		desplegables, tablas, etc.																	
	- Este paquete es una extensión del paquete AWT ques es otra biblioteca gráfica para Java pero que es mas básica.
	- La mayoria de las clases que pertenecen a este paquete empiezan por la letra "J" como pueden ser: JFrame, JButton, JLabel, etc.
	
2. Elemento JFrame (Marco).

	Un marco o JFrame es la zona donde se van a poder incluir todos los componentes que se quieren utilizar en la aplicación gráfica.
	
2.1. Características:
	
		- En la creación de un Frame en Java, por defecto nacen invisibles por lo que se necesita el método "setVisible()" para hacerlo visible.
		- Se crean con un tamaño inutil (0px largo x 0px ancho) por lo que se necesita el método "setSize()" para darles tamaño.
		- Se debe de indicar que debe de hacer el programa si se cierra un Frame con el método "setDefaultCloseOperation()".
		- Documentación Java: https://docs.oracle.com/javase/7/docs/api/javax/swing/JFrame.html
		- Importación de librería necesaria: javax.swing.JFrame;
		
2.2. Declaración de la clase para crear el marco o JFrame.

	- Se debe de extender la clase con la clase padre "JFrame" con "extends JFrame" en la declaración de la clase.
	- Se debe de crear el constructor vacío en el cual se debe de llamar a los siguientes métodos (Detalle archivo "Métodos paquete Swing.txt"):
	
		* Método this.setVisible(boolean valor).
		* Método this.setDefaultCloseOperation(int operacion).
		* Método this.setBounds(int pos_x, int pos_y, int largo, int ancho).
		* Método this.setTitle(String titulo).
		* Método this.setIconImage(Image icono).
	
	- Ejemplo: Crear un marco que las siguientes características:
	
		1) Tamaño: 500 x 300 pixeles
		2) Cambiar tamaño: No
		3) Visible: Si
		4) Botón cerrar: Se debe de cerrar la ventana.
		5) Titulo: Marco Fonsi
		6) Icono: icono de persona en la ruta especificada.
	
		import java.awt.Toolkit;
		import javax.swing.JFrame;

		// Se crea la clase para crear un Marco (JFrame).
		public class miMarco extends JFrame
		{
			
			// Declaración del constructor vacío.
			public miMarco()
			{
				
				// 1) Se establece el tamaño del marco.
				this.setSize(500, 300);
				
				// 2) Se indica que no se pueda redimensionar el marco.
				this.setResizable(false);
								
				// 3) Se indica que el marco sea visible.
				this.setVisible(true);
				
				// 4) Se indica que cuando se pulse el botón de salir, se cierre la pantalla.
				this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

				// 5) Se indica un título.
				this.setTitle("Marco Fonsi");
				
				// 6) Obtiene el dispositivo donde se muestra el marco, en este caso, en una pantalla.
				Toolkit miPantalla = Toolkit.getDefaultToolkit();
				
				// Se indica el icono que va a tener el marco indicando la ruta.
				this.setIconImage(miPantalla.getImage("C:\\CFGS\\Curso02_PildoraInformatica_Swing\\Bloque01_AplicacionesGraficas\\Seccion01_Elemento_JFrame\\icono.png"));
				
			}			
		}

2.3. Uso de la clase creada del marco.

	Para usar la clase "miMarco", como cualquier otra clase, solo se debe de crear un objeto de tipo "miMarco" y ejecutarla para que se muestre 
	visualmente el marco en pantalla.
	
	public class PruebaJFrame 
	{
	
		public static void main(String[] args) 
		{
			
			// Se crea un objeto de tipo "miMarco".
			miMarco marco = new miMarco();	
			
		}	
	}
		
2.4. Modificar la posición en pantalla donde aparece un marco (Video 56).

	Para poder modificar la posición en la que se inicia un marco se pueden utilizar los siguientes métodos:
	
		- Método setLocation(int pos_x, int pos_y): Se indica la posición x e y en pixeles donde se quiere posicionar el marco en la pantalla.
																								La posición que indicamos es la esquina superior izquierda de nuestro marco.
																								La posición (0, 0) es la esquina superior izquierda de la pantalla por lo que nos desplazamos hacia
																								la derecha y abajo cuando indicamos las coordenadas.
		
			// Se indica la ubicación en pantalla.
			this.setLocation(500, 300);
			
		- Método setBounds(int pos_x, int pos_y, int largo, int ancho): Se indica la posición x e y donde se quiere posicionar el marco en la pantalla 
																																		Este método es la unión entre el método "setSize()" y el método "setLocation()".
																																		
			// Se establece la posición (x, y) y el tamaño del marco (largo, ancho).
			this.setBounds(300, 400, 500, 300);			
			
2.5. Modificar la posición en pantalla de un marco para que aparezca totalmente centrado en la pantalla (Video 57).

	En el constructor de la clase se realizan las siguientes operaciones:
		
		import java.awt.Dimension;
		import java.awt.Toolkit;
		
		// Obtiene el dispositivo donde se muestra el marco, en este caso, en una pantalla.
		Toolkit miPantalla = Toolkit.getDefaultToolkit();
		
		// Se obtiene la resolución en pixeles de la pantalla.
		Dimension tamanioPantalla = miPantalla.getScreenSize();

		// Se obtiene la resolución del largo en pixeles de la pantalla.
		int largoPantalla = tamanioPantalla.width;
		// Se obtiene la resolución del alto en pixeles de la pantalla.
		int altoPantalla = tamanioPantalla.height;
		
		// Para situar el marco en el centro, en cuanto a la posición se divide entre 4 el largo y alto y en cuando a tamaño se divide entre 2 el largo y alto.
		this.setBounds(largoPantalla/4, altoPantalla/4, largoPantalla/2, altoPantalla/2);

